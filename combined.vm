#*
 *   $Id$
 *
 *   Copyright 2007,2008 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 *#

Note: lines not prefixed with [...] will be omitted in the final product.
The other prefixes are used by blitz/build.xml to determine how this file
wil be split. This is done because the individual velocity if/elseif's
and sets are nearly identical.

Here we turn off all prefixes except for ice.  Since <>I files are
concrete implementations, they should only be generated for concrete
classes. Capitalized versions will be turned on even for abstract classes.

#set( $ALL = "all" )
#set( $JAV = "jav" )
#set( $CPP = "cpp" )
#set( $HDR = "hdr" )
#set( $PYC = "pyc" )
#set( $ice = "ice" )
#set( $all = "all" )
#set( $jav = "jav" )
#set( $cpp = "cpp" )
#set( $hdr = "hdr" )
#set( $pyc = "pyc" )
#if($type.abstract)
#set( $all = "abs" )
#set( $jav = "abs" )
#set( $cpp = "abs" )
#set( $hdr = "abs" )
#set( $pyc = "abs" )
#end

Copyright notice added to all files:
[$pyc] """
[$ALL] /*
[$ALL]  *   Generated by blitz/templates/resouces/combined.vm
[$hdr]  *   See ../../README.h for information on these types.
[$ice]  *   See ../../README.ice for information on these types.
[$ALL]  *
[$ALL]  *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
[$ALL]  *   Use is subject to license terms supplied in LICENSE.txt
[$ALL]  *
[$ALL]  */
[$pyc] """

CONSTANTS -- Don't change for whole file
#set($Pojo  = "${type.shortname}")
#set($PojoI = "${Pojo}I")
#set($POJO  = "${Pojo.toUpperCase()}")
#set($POJOI = "${PojoI.toUpperCase()}")
#set($JAV_CURRENT = "Ice.Current current" )
#set($PYC_CURRENT = "current = Ice.Current()" )
#set($CPP_CURRENT = "const Ice::Current& current" )
#set($HDR_CURRENT = "${CPP_CURRENT} = Ice::Current()")


DECLARATION BLOCK:
=====================================================================================================

[$ice] #ifndef ${POJO}_ICE
[$ice] #define ${POJO}_ICE
[$hdr] #ifndef ${POJOI}_H
[$hdr] #define ${POJOI}_H

[$ice] \#include <omero/fwd.ice>
[$ice] \#include <omero/IObject.ice>
[$ice] \#include <omero/RTypes.ice>
[$ice] \#include <omero/System.ice>
#if( $type.superclass )
#set( $parent = $type.superclass.replaceFirst(".*ome.model..+?[.]","") )
[$ice] \#include <omero/model/${parent}.ice>
#set( $include = '\#include' )
#set( $importModify = '.replaceAll("^","[ice]").replaceAll(".*java.*","").replaceAll("import.*[.](.*?);","$include <omero/model/$1.ice>") ' )
\$secondpassclassimports\$importModify
#end
[$hdr] \#include <omero/ClientErrors.h>
[$hdr] \#include <omero/IObject.h>
[$hdr] \#include <omero/model/DetailsI.h>
[$hdr] \#include <omero/model/${Pojo}.h>
[$hdr] \#include <omero/ModelI.h>

[$ice] module omero {
[$ice]   module model {

[$jav] package omero.model;
[$jav] import  java.util.*;
[$jav] import  ome.conditions.*;
[$jav] public class ${PojoI} extends ${Pojo}
[$jav]    implements ome.model.ModelBased {

Note how the whitespace for the python definitions is important.
[$pyc] import Ice
[$pyc] import omero_model_DetailsI
[$pyc] import omero_model_${Pojo}_ice
[$pyc] _omero = Ice.openModule("omero")
[$pyc] _omero_model = Ice.openModule("omero.model")
[$pyc] __name__ = "omero.model"

[$pyc] class ${PojoI}(_omero_model.$Pojo):
[$pyc]
[$hdr] namespace omero { 
[$hdr]   namespace model {
[$hdr]     class ${PojoI} : virtual public ${Pojo} { 

[$cpp] \#include <omero/model/${Pojo}I.h>
[$cpp] namespace omero { 
[$cpp]   namespace model {

STATIC FIELDS:

#foreach( $property in $type.propertyClosure )
[$jav]       public final static String ${property.nameUpper} = "${type.id}_${property.name}";
[$pyc]       ${property.nameUpper} =  "${type.id}_${property.name}"
[$hdr]       static const string ${property.nameUpper};
[$cpp]       const ${PojoI}::${property.nameUpper} =  "${type.id}_${property.name}";
#end

[$hdr]     protected:

GENERATOR:

[$pyc]       class ${Pojo}I_generator:
[$pyc]           """
[$pyc]           This generator is used by the ObjectFactory to create
[$pyc]           new ${Pojo}I instances.
[$pyc]           """
[$pyc]           def __iter__(self):
[$pyc]               return self
[$pyc]           def next(self):
[$pyc]               return ${Pojo}I()
[$pyc]
[$pyc]       def generator(cls):
[$pyc]           return cls.${Pojo}I_generator()
[$pyc]       generator = classmethod(generator)
[$pyc]

INTERNAL METHODS:

[$hdr]       void errorIfUnloaded();
[$cpp]       void ${PojoI}::errorIfUnloaded()
[$cpp]       {
[$cpp]         if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
[$cpp]       }
[$jav]       protected void errorIfUnloaded() throws omero.UnloadedEntityException
[$jav]       {
[$jav]         if ( ! loaded ) throw new omero.UnloadedEntityException("Object unloaded:"+this);
[$jav]       }
[$pyc]       def errorIfUnloaded(self):
[$pyc]           if not self.loaded:
[$pyc]               raise _omero.UnloadedEntityException("Object unloaded:"+str(self))
[$pyc]
[$hdr]       void throwNullCollectionException(std::string propertyName);
[$cpp]       void ${PojoI}::throwNullCollectionException(std::string propertyName)
[$cpp]       {
[$cpp]         std::string s = "Error updating collection:" + propertyName +"\n"+
[$cpp]         "Collection is currently null. This can be seen\n"+
[$cpp]         "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$cpp]         "that this collection was unloaded. Please refresh this object\n"+
[$cpp]         "in order to update this collection.\n";
[$cpp]         throw omero::UnloadedCollectionException(
[$cpp]            __FILE__,__LINE__,s.c_str());
[$cpp]       }
[$jav]       protected void throwNullCollectionException(String propertyName) throws omero.UnloadedCollectionException
[$jav]       {
[$jav]          throw new omero.UnloadedCollectionException(
[$jav]            "Error updating collection:" + propertyName +"\n"+
[$jav]            "Collection is currently null. This can be seen\n"+
[$jav]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$jav]            "that this collection was unloaded. Please refresh this object\n"+
[$jav]            "in order to update this collection.\n"
[$jav]            );
[$jav]       }
[$pyc]       def throwNullCollectionException(self,propertyName):
[$pyc]           raise _omero.UnloadedEntityException(""+
[$pyc]           "Error updating collection:" + propertyName +"\n"+
[$pyc]           "Collection is currently null. This can be seen\n" +
[$pyc]           "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$pyc]           "that this collection was unloaded. Please refresh this object\n"+
[$pyc]           "in order to update this collection.\n")
[$pyc]

DESTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       virtual ~${PojoI}();
[$cpp]     ${PojoI}::~${PojoI}() {}

[$hdr]     public:


DEFAULT CONSTRUCTOR BLOCK:
=====================================================================================================


[$hdr]       ${PojoI}();
[$jav]       public ${PojoI}() {
[$cpp]       ${PojoI}::${PojoI}() : ${Pojo}() {
[$cpp]           loaded = true;
[$cpp]           toggleCollectionsLoaded(true);
[$cpp]           details = new omero::model::DetailsI();
[$jav]           loaded = true;
[$jav]           toggleCollectionsLoaded(true);
[$jav]           details = new omero.model.DetailsI();
[$jav]       }
[$cpp]       }

Python combines the two constructors. See below for a comparison.
[$pyc]       def __init__(self,id = None,loaded = True):
[$pyc]           super(${Pojo}I, self).__init__()
[$pyc]           self.id = id
[$pyc]           self.loaded = loaded
[$pyc]           if self.loaded:
[$pyc]              self.details = _omero_model.DetailsI()
[$pyc]              self.toggleCollectionsLoaded(True)
[$pyc]

TOGGLE AND CREATE COLLECTIONS:
=====================================================================================================

[$jav]       public void toggleCollectionsLoaded(boolean load) {
[$hdr]       virtual void toggleCollectionsLoaded(bool load);
[$cpp]    void ${PojoI}::toggleCollectionsLoaded(bool load) {
[$pyc]       def toggleCollectionsLoaded(self,load):
#foreach( $property in $type.propertyClosure )
#set(     $PropertyName = $property.nameCapped )
#set(     $javaType = $property.type)
#set(     $seqName = "${Pojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set($genericType = $property.type)
#set($genericType = $genericType.replaceFirst("ome.model..+?[.]","omero::model::"))
#set($genericTypeC = "${genericType.replaceAll('[.]','::')}")

Here we don't have to keep up with the type (set/list)
since all collections are lists in ice.

#if(      $fulltype.contains("byte[]"))
[$ice]     sequence<byte> ${seqName};

#elseif(  $property.one2Many )

[$ice]     ["java:type:java.util.ArrayList"] sequence<$genericTypeC> ${seqName};

[$jav]           if (load) {
[$jav]               ${property.name}Seq = new ArrayList();
[$jav]               ${property.name}Loaded = true;
[$jav]           } else {
[$jav]               ${property.name}Seq = null;
[$jav]               ${property.name}Loaded = false;
[$jav]           }
[$cpp]           if (load) {
[$cpp]               ${property.name}Seq = ${seqName}();
[$cpp]               ${property.name}Loaded = true;
[$cpp]           } else {
[$cpp]               ${property.name}Seq = (${seqName})0;
[$cpp]               ${property.name}Loaded = false;
[$cpp]           }
[$pyc]           if load:
[$pyc]               self.${property.name}Seq = []
[$pyc]               self.${property.name}Loaded = True;
[$pyc]           else:
[$pyc]               self.${property.name}Seq = []
[$pyc]               self.${property.name}Loaded = False;
[$pyc]
#end##byte[]
#end##FOREACH
[$jav]    }
[$cpp]    }
##               In case there are no collections
[$pyc]           pass
[$pyc]

ICE CLASS BLOCK:
=====================================================================================================

Calculate inheritance. This is done here because sequences must first be defined.

#set( $base = "omero::model::IObject" )
#set( $extendsDeclaration = $base )
#if(  $type.superclass )
#set( $extendsDeclaration = $type.superclass.replaceFirst("ome.model..+?[.]","omero::model::" ) )
#end

[$ice]     ["protected"] class ${type.shortname}
[$ice]     extends $extendsDeclaration
[$ice]     {

UNLOADED CONSTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       ${PojoI}(omero::RLongPtr idPtr, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(omero::RLongPtr idPtr, bool isLoaded) : ${Pojo}() {
[$cpp]      id = idPtr;
[$cpp]      loaded = isLoaded;
[$cpp]      if (loaded) details = new omero::model::DetailsI(); 
[$cpp]      toggleCollectionsLoaded(isLoaded);
[$cpp]    }
[$jav]    public ${PojoI}(long id, boolean loaded) {
[$jav]      this.id = new omero.RLong(id);
[$jav]      this.loaded = loaded; 
[$jav]      if (loaded) details = new omero.model.DetailsI();
[$jav]    }
See single Python constructor above.

LOADNESS BLOCK:
=====================================================================================================

[$jav]       public void unload(Ice.Current current) {
[$hdr]       virtual void unload(const Ice::Current& current = Ice::Current());
[$cpp]       void ${PojoI}::unload(const Ice::Current& current) {
[$pyc]       def unload(self, current = Ice.Current()):
[$pyc]           self.loaded = False
[$jav]           loaded = false;
[$cpp]           loaded = false;
#foreach($property in $type.propertyClosure)
#if(!$clazz.identifierProperty.equals($property))
#set( $PropertyName = $property.nameCapped )
[$jav]           unload${PropertyName}( );
[$cpp]           unload${PropertyName}( );
[$pyc]           self.unload${PropertyName}( )
#end
#end##FOREACH
[$pyc]
[$jav]    }
[$cpp]    }

[$jav]       public boolean isLoaded(Ice.Current current) {
[$hdr]       virtual bool isLoaded(const Ice::Current& current = Ice::Current());
[$cpp]       bool ${PojoI}::isLoaded(const Ice::Current& current) {
[$pyc]       def isLoaded(self, current = Ice.Current()):
[$pyc]           return self.loaded
[$jav]           return loaded;
[$cpp]           return loaded;
[$jav]    }
[$cpp]    }

INTERFACE METHODS:
=====================================================================================================
Since all the language bindings don't support the concept of interfaces,
the IObject abstract base class declares several methods that all concrete
implementations must define.

[$jav]       public boolean isGlobal($JAV_CURRENT) {
[$cpp]           return #if($type.global)true#elsefalse#end;
[$jav]       }
[$hdr]       virtual bool isGlobal($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isGlobal($CPP_CURRENT) {
[$cpp]           return #if($type.global)true#elsefalse#end;
[$cpp]       }
[$pyc]       def isGlobal(self, $PYC_CURRENT):
[$pyc]           return #if($type.global)True#elseFalse#end;

[$jav]       public boolean isMutable($JAV_CURRENT) {
[$cpp]           return #if($type.immutable)false#elsetrue#end;
[$jav]       }
[$hdr]       virtual bool isMutable($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isMutable($CPP_CURRENT) {
[$cpp]           return #if($type.immutable)false#elsetrue#end;
[$cpp]       }
[$pyc]       def isMutable(self, $PYC_CURRENT):
[$pyc]           return #if($type.immutable)False#elseTrue#end;

[$jav]       public boolean isAnnotated($JAV_CURRENT) {
[$cpp]           return #if($type.annotated)true#elsefalse#end;
[$jav]       }
[$hdr]       virtual bool isAnnotated($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isAnnotated($CPP_CURRENT) {
[$cpp]           return #if($type.annotated)true#elsefalse#end;
[$cpp]       }
[$pyc]       def isAnnotated(self, $PYC_CURRENT):
[$pyc]           return #if($type.annotated)True#elseFalse#end;

[$jav]       public boolean isLink($JAV_CURRENT) {
[$cpp]           return #if($type.isLink)true#elsefalse#end;
[$jav]       }
[$hdr]       virtual bool isLink($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isLink($CPP_CURRENT) {
[$cpp]           return #if($type.isLink)true#elsefalse#end;
[$cpp]       }
[$pyc]       def isLink(self, $PYC_CURRENT):
[$pyc]           return #if($type.isLink)True#elseFalse#end;


SPECIAL METHODS:
=====================================================================================================
Id and Details acccesors defined like accessors below. This is necessary here
since id and details (like the loadedness methods above) are defined in IObject.ice
and cannot appear in every concrete <>I class. Therefore, we define them here
and protect later FOREACH blocks with "if (name == 'id' || name == 'details') skip;"

[$jav]       public omero.RLong getId(Ice.Current current) {
[$jav]           return id;
[$jav]       }
[$jav]
[$jav]       public void setId( omero.RLong id, Ice.Current current ) {
[$jav]           this.id = id;
[$jav]       }
[$jav]
[$jav]       public omero.model.Details getDetails(Ice.Current current) {
[$jav]           return this.details;
[$jav]       }
[$jav]
[$jav]       public void unloadDetails() {
[$jav]           this.details = null;
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by copyObject below to take an ome.model instance and
[$jav]        * set the values on this instance.
[$jav]        */
[$jav]       private void copyDetails(ome.model.IObject source, omero.util.IceMapper mapper) {
[$jav]           this.details = (omero.model.Details) mapper.findTarget( source.getDetails() );
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by fillObject below to take this instance and
[$jav]        * set the values on the target ome.model. instance.
[$jav]        */
[$jav]       private void fillDetails(ome.model.IObject target, omero.util.IceMapper mapper) {
[$jav]           ome.model.internal.Details details = (ome.model.internal.Details) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() );
[$jav]           if (details != null) {
[$jav]               target.getDetails().copy( details );
[$jav]           }
[$jav]       }
[$jav]

[$hdr]       virtual omero::model::DetailsPtr getDetails($HDR_CURRENT);
[$hdr]       virtual void unloadDetails();
[$hdr]       virtual omero::RLongPtr getId($HDR_CURRENT);
[$hdr]       virtual void setId( omero::RLongPtr id, $HDR_CURRENT );

[$cpp]       omero::model::DetailsPtr ${PojoI}::getDetails($CPP_CURRENT) {
[$cpp]           return details;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}:unloadDetails() {
[$cpp]           details = new omero::model::DetailsPtr();
[$cpp]       }
[$cpp]
[$cpp]       omero::RLongPtr ${PojoI}::getId($CPP_CURRENT) {
[$cpp]           return id;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setId(omero::RLongPtr _id, $CPP_CURRENT) {
[$cpp]           id = _id;
[$cpp]       }

[$pyc]       def getDetails(self, current = Ice.Current()):
[$pyc]           return self.details
[$pyc]
[$pyc]       def unloadDetails(self):
[$pyc]           self.details = None
[$pyc]
[$pyc]       def getId(self, current = Ice.Current()):
[$pyc]           return self.id
[$pyc]
[$pyc]       def setId(self, _id, current = Ice.Current()):
[$pyc]           self.id = _id
[$pyc]
Doing unloadedPython as a method because of the multi-line restriction. See below.
[$pyc]       def checkUnloadedProperty(self, value, loadedField):
[$pyc]           if value == None:
[$pyc]               self.__dict__[loadedField] = False
[$pyc]           else:
[$pyc]               self.__dict__[loadedField] = True
[$pyc]

###########################################################################
#foreach($property in $type.propertyClosure)#############
###########################################################################

This is the main loop through all of the properties. Where possible, methods
should be created here which simplify the other sections of code generation.

ACCESSORS BLOCK:
=====================================================================================================

These mappings are from HibernateTypes-->IceTypes

Ice properties should only be defined once (not in every subclass, obviously).
However, because of Ice's inheritance structure, we are here using
propertyClosure which gives us superclass fields. These must be filtered
in the [Ice] sections below, but not for all others.

#if( $property.name.equals("id") || $property.name.equals("details"))## SPECIAL EXCEPTIONS

Skip. These are defined in omero.IObject.ice

#elseif($property.name.equals("version"))
#if($extendsDeclaration.equals($base))
             // Version in superclass
[$Ice]       omero::RInt version;
#end

#else## All other properties are treated normally

[$hdr]
[$hdr]       //
[$hdr]       //  ${Pojo}.${property.name}
[$hdr]       //

#set( $definedIn = "nothere" )
#foreach( $p2 in $type.classProperties )
##
#if( $p2.name.equals($property.name) )
#set( $definedIn = "here" )
#end
#end
#set($Ice = "ice" )
#if( $definedIn.startsWith("not") )
#set($Ice = "NOT" )
#end


Properties used throughout the accessor generation

## TODO: UNIFY THESE
#set( $PropertyName = $property.nameCapped)
#set( $STATICFIELDNAME = "${type.id}.${PropertyName.toUpperCase()}" )
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $iceType = "ERROR" )## Must be reset on each iteration
#set( $cppType = "ERROR" )##  ditto
#set( $open = " " )
#set( $close= " " )
#set( $prefix=" " )
#set( $suffix=" " )
#set( $unloadedJava=" " )
#set( $unloadedCpp=" " )
#set( $unloadedPython="pass" )
#set( $copyMethod = "source.get$PropertyName()" )
#set( $findMethod = "Target" )
#set( $fieldName = "${property.name}") ## Changed for sequences to nameSeq
#set( $getter = "this.${fieldName}" )
#set( $setter = "${fieldName}" )

 TODO: Currently the findTarget methods have separate names.
 Instead there should be a cast to guarantee that the right
 method is invoked.

## Here we are taking the pojo name from the ST of the property, rather than the
## current ST in order to handle subclasses wrt. links. This may need to be done for
## every property right after the foreach.
#set( $truePojo = "${property.getST().shortname}" )
#set( $seqName = "${truePojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set( $propLoaded = "${property.Name}Loaded" )

## TODO use empty List or null?

#if( $property.one2Many )##JAVA_TYPE ----------------------------------------------
## #684 Mapping all sets to lists.
#set( $javaType = "java.util.List" )
#set( $getter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( this.$property.name ) " )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( $property.name )" )
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $iceType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} != ($cppType) 0) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )
#set( $unloadedPython = "self.checkUnloadedProperty(_${property.name},'${propLoaded}')" )
## See ticket:684
## If this is the case, we can't use the accessor and have to use a generated method
#set( $copyMethod = "(Collection) source.retrieve(${type.id}.${PropertyName.toUpperCase()})" )
#set( $findMethod = "Collection")
#set( $fieldName = "${property.name}Seq")
#set( $getter = "this.${fieldName}" )
#set( $setter = "${fieldName}" )


[$Ice]       $seqName ${fieldName};
[$Ice]       bool ${property.name}Loaded;
#if( $property.isLink )
[$Ice]       omero::sys::CountMap ${property.name}CountPerOwner;
#end

#elseif( $javaType.startsWith("ome"))## Had to be moved before "*Map" rule ---------
#set( $javaType = "omero.model.${shortType}" )
#set( $getter = "(omero.model.${shortType}) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::${shortType}" )
#set( $cppType = "${iceType}Ptr" )
[$Ice]       omero::model::${shortType} ${property.name};

#elseif( $javaType.startsWith("IObject"))## Special case of the previous------------
#set( $javaType = "omero.model.IObject")
#set( $getter = "(omero.model.IObject) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::IObject")
#set( $cppType = "${iceType}Ptr")
[$Ice]       omero::model::IObject ${property.name};

#elseif( $javaType.startsWith("java.lang.Boolean"))## -------------------------------
#set( $javaType = "omero.RBool");
#set( $iceType   = "omero::RBool" )
#set( $cppType   = "${iceType}Ptr" )
[$Ice]       omero::RBool ${property.name};

#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $javaType = "omero.RInt");
#set( $iceType   = "omero::RInt" )
#set( $cppType   = "${iceType}Ptr" )
[$Ice]       omero::RInt ${property.name};

#elseif( $javaType.startsWith("java.lang.Long"))
#set( $javaType = "omero.RLong");
#set( $iceType   = "omero::RLong" )
#set( $cppType   = "${iceType}Ptr" )
[$Ice]       omero::RLong ${property.name};

#elseif( $javaType.startsWith("java.lang.Double"))
#set( $javaType = "omero.RDouble");
#set( $iceType   = "omero::RDouble" )
#set( $cppType   = "${iceType}Ptr" )
[$Ice]       omero::RDouble ${property.name};

#elseif( $javaType.startsWith("java.lang.Float"))
#set( $javaType = "omero.RFloat");
#set( $iceType   = "omero::RFloat" )
#set( $cppType   = "${iceType}Ptr" )
[$Ice]       omero::RFloat ${property.name};

#elseif( $javaType.equals("byte[]"))
#set( $javaType = "byte[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::ByteSeq")
#set( $cppType = "Ice::ByteSeq")
[$Ice]       Ice::ByteSeq ${property.name};

#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "Long" )
#set( $getter   = "new Long(this.$property.name)" )
#set( $setter = "(${property.name} == null) ? 0 : this.$property.name == ${property.name}.longValue()")
#set( $iceType = "long" )
#set( $cppType = "long" )
#set( $copyMethod = "ome.util.Utils.internalForm(source)" )
[$Ice]       long ${property.name};

#elseif( $javaType.startsWith("java.util.Map") )
#set( $findMethod = "Map" )
[$Ice]       dictionary ${property.name};

#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $javaType = "omero.RTime");
#set( $iceType = "omero::RTime" )
#set( $cppType = "${iceType}Ptr" )
[$Ice]       omero::RTime ${property.name};

#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $javaType = "omero.RString");
#set( $iceType = "omero::RString" )
#set( $cppType = "${iceType}Ptr" )
[$Ice]       omero::RString ${property.name};

#else
[$all]...ERROR...$javaType unknown.

#end##JAVA_TYPE

Here we only add the getters and setters to Ice, if this is not a collection.
Otherwise the special collection methods below will be used for access.

#if( ! $property.one2Many )
[$Ice]       $iceType get${PropertyName}();
[$Ice]       void set${PropertyName}($iceType the${PropertyName});
#end

ASSOCIATION TYPES BLOCK:
=====================================================================================================

#set( $hasSet  = false )
#set( $hasLink = false )
#if( $property.one2Many )
#set( $hasSet  = $property.one2Many)
#end
#if( $property.class.name.equals("ome.dsl.ChildLink") || $property.class.name.equals("ome.dsl.ParentLink"))
#set( $hasLink = true )
#end

#set( $access = "protected" )
#set( $unloadIfIsSet = "${property.Name}Loaded = false;")
#if( !$hasSet && !$hasLink)
#set( $access = "public" )
#set( $unloadIfIsSet = "");
#end

Unload
------

[$jav]       public void unload${PropertyName}() {
[$jav]           ${unloadIfIsSet}
[$jav]           ${fieldName} = null;
[$jav]       }
[$hdr]       virtual void unload${PropertyName}();
[$cpp]       void ${Pojo}I::unload${PropertyName}() {
[$cpp]           ${unloadIfIsSet}
[$cpp]           ${fieldName} = ($cppType) 0;
[$cpp]       }
[$pyc]       def unload${PropertyName}(self):
[$pyc]           self.${property.name}Loaded = False
[$pyc]           self.${fieldName} = None;
[$pyc]
Original accessors: will have their visibility reduced if
the special set methods are added.

[$jav]       $access $javaType get${property.nameCapped}(Ice.Current current) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return $getter;
[$jav]       }
[$jav]
[$jav]       $access void set${PropertyName}($javaType $property.name, Ice.Current current) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           this.$fieldName = $setter;
[$jav]           $unloadedJava
[$jav]       }
[$jav]
[$jav]       private void copy${PropertyName}($type.id source, omero.util.IceMapper mapper) {
[$jav]           this.${fieldName} = ($javaType) mapper.find${findMethod}($copyMethod);
#if ($property.one2Many && $property.isLink)
[$jav]           this.${property.name}CountPerOwner = source.get${property.nameCapped}CountPerOwner();
#end
[$jav]       }
[$jav]
[$jav]       private void fill${PropertyName}($type.id target, omero.util.IceMapper mapper) {
#if( $type.id.equals("ome.model.internal.Permissions") )
[$jav]             ome.model.internal.Permissions p = ome.util.Utils.toPermissions((Long)this.getPerm1());
[$jav]             target.revokeAll(ome.model.internal.Permissions.EMPTY); // AND
[$jav]             target.grantAll(p); // OR

#elseif( $property.one2Many )
## If this is the case, we can't use the accessor and have to use a generated method

[$jav]             if (this.${propLoaded}) {

ticket:684 This is necessary to map back and forth from sets.
#set( $fieldType = $property.fieldType.replaceAll("[<].*[>]",""))
[$jav]               target.putAt( $STATICFIELDNAME, mapper.reverse( this.${fieldName}, ${fieldType}.class ));
[$jav]             } else {
[$jav]               target.putAt( $STATICFIELDNAME, null );
[$jav]             }

#elseif( $javaType.startsWith("ome") )
[$jav]             target.putAt($STATICFIELDNAME, ($javaType) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("IObject") )
[$jav]             target.set${PropertyName}( (ome.model.IObject) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("long"))
 ----------------> ERROR
#else
[$jav]             target.set${PropertyName}( this.get${PropertyName}() );
#end
[$jav]       }
[$jav]


#if($access == "protected" )
[$hdr]     protected:
#end
[$hdr]       virtual $cppType get${property.nameCapped}(const Ice::Current& current = Ice::Current());
[$hdr]       virtual void set${PropertyName}($cppType _$property.name, const Ice::Current& current = Ice::Current());
#if($access == "protected" )
[$hdr]     public:
#end

[$cpp]       $cppType ${PojoI}::get${property.nameCapped}(const Ice::Current& current) {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${open}${fieldName}${close};
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::set${PropertyName}($cppType _$property.name, const Ice::Current& current) {
[$cpp]           errorIfUnloaded();
[$cpp]           $fieldName = $!{prefix}_${property.name}$!{suffix};
[$cpp]           $unloadedCpp
[$cpp]       }

[$pyc]       def get${property.nameCapped}(self, current = Ice.Current()):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.${fieldName}
[$pyc]
[$pyc]       def set${PropertyName}(self, _${property.name}, current = Ice.Current()):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.${fieldName} = _${property.name}
[$pyc]           $unloadedPython
[$pyc]

One-to-many extras:
======================================================================================

#if( $hasSet || $hasLink )

[$jav]       public boolean is${PropertyName}Loaded() {
[$jav]           return ${propLoaded};
[$jav]       }
[$hdr]       virtual bool is${PropertyName}Loaded();
[$cpp]       bool ${PojoI}::is${PropertyName}Loaded( ) {
[$cpp]           return ${propLoaded};
[$cpp]       }
[$pyc]       def is${PropertyName}Loaded(self):
[$pyc]           return self.${propLoaded}
[$pyc]

sizeOf ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       int sizeOf${PropertyName}();
[$jav]       public int sizeOf${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) return -1;
[$jav]           return ${fieldName}.size();
[$jav]       }
[$hdr]       virtual Ice::Integer sizeOf${PropertyName}($HDR_CURRENT);
[$cpp]       Ice::Integer ${PojoI}::sizeOf${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) return -1;
[$cpp]           return ${fieldName}.size();
[$cpp]       }
[$pyc]       def sizeOf${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: return -1
[$pyc]           return len(self.${fieldName})
[$pyc]

Copy ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       $iceType copy${PropertyName}();
[$jav]       public $javaType copy${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$javaType> result = new ArrayList(${fieldName});
[$jav]           return result;
[$jav]       }
[$pyc]       def copy${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return list(self.${fieldName})
[$pyc]
             Here we don't have a vector<$cppType> since the type is typedef'd
[$hdr]       virtual $cppType copy${PropertyName}($HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::copy${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType result(${fieldName}.size());
[$cpp]           std::copy(${fieldName}.begin(), ${fieldName}.end(), result.begin());
[$cpp]           return result;
[$cpp]       }

Iterators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Iterators are language-specific since there's no slice concept
for them. Therefore, to use these, developers must down-cast.

[$jav]       public Iterator iterate${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.iterator();
[$jav]       }
[$hdr]       virtual $cppType::iterator begin${PropertyName}();
[$hdr]       virtual $cppType::iterator end${PropertyName}();
[$cpp]       $cppType::iterator ${PojoI}::begin${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.begin();
[$cpp]       }
[$cpp]       $cppType::iterator ${PojoI}::end${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.end();
[$cpp]       }
[$pyc]       def iterate${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return iter(self.${fieldName})
[$pyc]

#end


------------------------------------------------------------
Because of the ice inheritance hierarchy, we must use direct
field access on several methods below.
------------------------------------------------------------

Set modifications:

#if( $hasSet )
#set( $inverse = $property.inverse )
#set( $inverselength = $inverse.length() )
#set( $Inverse = "${inverse.substring(0,1).toUpperCase()}${inverse.substring(1,$inverselength)}" )

add single

[$Ice]       void add${property.shortType}(${property.shortType} target);
[$jav]       public void add${property.shortType}(${property.shortType} target, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( target );
[$jav]           target.$inverse = this;
[$jav]       }
[$pyc]       def add${property.shortType}(self, target, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self.${fieldName}.append( target );
[$pyc]           target.$inverse = self;
[$pyc]
[$hdr]       virtual void add${property.shortType}(${property.shortType}Ptr target, $HDR_CURRENT);
[$cpp]       void ${PojoI}::add${property.shortType}(${property.shortType}Ptr target, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( target );
[$cpp]           target->$inverse = this;
[$cpp]       }

add set

[$jav]       public void add${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.addAll( targets );
[$jav]           for( ${property.shortType} target : targets) {
[$jav]               target.$inverse = this;
[$jav]           }
[$jav]       }
[$pyc]       def add${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if  not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self.${fieldName}.extend( targets )
[$pyc]           for target in targets:
[$pyc]               target.$inverse = self
[$pyc]
[$hdr]       virtual void add${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::add${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator loc = ${fieldName}.end();
[$cpp]           $cppType::iterator beg = targets.begin(); 
[$cpp]           $cppType::iterator end = targets.end(); 
[$cpp]           ${fieldName}.insert(loc,beg,end);
[$cpp]           for ($cppType::iterator it = targets.begin(); it != targets.end(); ++it) {
[$cpp]               ${property.shortType}Ptr target = *it;
[$cpp]               target->$inverse = this;
[$cpp]           }
[$cpp]       }

remove single

#set( $removePredicate = "testRemove${property.shortType}From${PojoI}" )
[$cpp]       struct $removePredicate
[$cpp]       {
[$cpp]           const ${property.shortType}Ptr t;
[$cpp]           ${removePredicate}(const ${property.shortType}Ptr n) : t(n) {}
[$cpp]           bool operator()(${property.shortType}Ptr const& o) {
[$cpp]               return o == t;
[$cpp]           }
[$cpp]       };

[$jav]       public void remove${property.shortType}(${property.shortType} target) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( target );
[$jav]           target.$inverse = null;
[$jav]       }
[$pyc]       def remove${property.shortType}(self, target):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self.${fieldName}.remove( target )
[$pyc]           target.$inverse = None
[$pyc]
[$hdr]       virtual void remove${property.shortType}(${property.shortType}Ptr target);
[$cpp]       void ${PojoI}::remove${property.shortType}(${property.shortType}Ptr target) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               ${removePredicate}(target));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]           target->$inverse = (${PojoI}Ptr)0;
[$cpp]       }

remove multiple

#set( $removeSetPredicate = "testRemove${property.shortType}SetFrom${PojoI}" )
[$cpp]       struct ${removeSetPredicate}
[$cpp]       {
[$cpp]           const ${cppType} t;
[$cpp]           ${removeSetPredicate}(const ${cppType} n) : t(n) {}
[$cpp]           bool operator()(${property.shortType}Ptr const& o) {
[$cpp]               return std::find(t.begin(), t.end(), o) != t.end();
[$cpp]           }
[$cpp]       };

[$jav]       public void remove${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : targets) {
[$jav]               elt.$inverse = null;
[$jav]               ${fieldName}.remove( elt );
[$jav]           }
[$jav]       }
[$pyc]       def remove${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in targets:
[$pyc]               elt.$inverse = None
[$pyc]               self.${fieldName}.remove( elt )
[$pyc]
[$hdr]       virtual void remove${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::remove${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${cppType}::iterator end = ${fieldName}.end();
[$cpp]           ${cppType}::iterator removed = std::remove_if(
[$cpp]               ${fieldName}.begin(), end,
[$cpp]               $removeSetPredicate(targets));
[$cpp]           ${cppType}::iterator beg(removed);
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->$inverse = (${PojoI}Ptr)0;
[$cpp]           }
[$cpp]           ${fieldName}.erase(removed,end);
[$cpp]       }

clear

[$Ice]       void clear${PropertyName}();
[$jav]       public void clear${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : (Collection<${property.shortType}>)${fieldName}) {
[$jav]               elt.$inverse = null;
[$jav]           }
[$jav]           ${fieldName}.clear();
[$jav]       }
[$pyc]       def clear${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in self.${fieldName}:
[$pyc]               elt.$inverse = None
[$pyc]           self.${fieldName} = list()
[$pyc]
[$hdr]       virtual void clear${PropertyName}($HDR_CURRENT);
[$cpp]       void ${PojoI}::clear${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator beg = ${fieldName}.begin();
[$cpp]           $cppType::iterator end = ${fieldName}.end();
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->$inverse = (${PojoI}Ptr)0;
[$cpp]           }
[$cpp]           ${fieldName}.clear();
[$cpp]       }

Link Modifications

#if( $hasLink )

Here our "elements" from the above are the links which themselves
have linked elements.

#if($property.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "parent" )
#set( $other = "child" )
#elseif($property.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "child" )
#set( $other = "parent" )
#end
#set( $bidir = $property.bidirectional )
#set( $pyorder = $order.replaceAll("this","self"))

COUNTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#set( $GETCOUNTMETHOD = "get${property.nameCapped}CountPerOwner" )
#set( $GETCOUNTVALUE  = "${property.name}CountPerOwner" )
[$Ice]       omero::sys::CountMap $GETCOUNTMETHOD();
[$jav]       public java.util.Map<Long, Long> $GETCOUNTMETHOD($JAV_CURRENT) {
[$jav]           return this.$GETCOUNTVALUE;
[$jav]       }
[$jav]
[$hdr]       virtual omero::sys::CountMap $GETCOUNTMETHOD($HDR_CURRENT);
[$cpp]       void ${PojoI}::$GETCOUNTMETHOD($CPP_CURRENT) {
[$cpp]           return $GETCOUNTVALUE;
[$cpp]       }
[$pyc]       def $GETCOUNTPEROWNER(self, $PYC_CURRENT):
[$pyc]           return $GETCOUNTVALUE


ADD ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#set( $ADD2METHOD = "add${property.shortType}2")

[$Ice]       void link${property.shortTarget}(${property.shortTarget} addition);
[$jav]       public void link${property.shortTarget}(${property.shortTarget} addition, Ice.Current current) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${property.shortType}I link = new ${property.shortType}I();
[$jav]           link.link( ${order} );
[$jav]           $ADD2METHOD( link, true );
[$jav]       }
[$pyc]       def link${property.shortTarget}(self, addition, current = Ice.Current()):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           link = _omero_model.${property.shortType}I()
[$pyc]           link.link( ${pyorder} );
[$pyc]           self.$ADD2METHOD( link, True )
[$pyc]
[$hdr]       virtual void link${property.shortTarget}(const ${property.shortTarget}Ptr& addition, $HDR_CURRENT);
[$cpp]       void ${PojoI}::link${property.shortTarget}(const ${property.shortTarget}Ptr& addition, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${property.shortType}IPtr link = new ${property.shortType}I();
[$cpp]           link->link( ${order} );
[$cpp]           $ADD2METHOD( link, true );
[$cpp]       }

TODO: do we need to do link.parent = ...;

[$Ice]       void $ADD2METHOD(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void $ADD2METHOD(${property.shortType} link, boolean bothSides, Ice.Current current) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( link );
#if($bidir)
TODO: Should we check for nulls in other?
[$jav]           if (bothSides && link.${other}.loaded ) {
[$jav]               ((${property.shortTarget})link.${other}).$ADD2METHOD( link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def $ADD2METHOD(self, link, bothSides):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self.${fieldName}.append( link )
#if($bidir) 
[$pyc]           if bothSides and link.${other}.loaded:
[$pyc]               link.${other}.$ADD2METHOD( link, False )
#end
[$pyc]
[$hdr]       virtual void $ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current = Ice::Current());
[$cpp]       void ${PojoI}::$ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( link );
#if($bidir)
[$cpp]           if (bothSides && link->${other}->loaded ) {
[$cpp]               ${property.shortTarget}Ptr::dynamicCast(link->${other})->$ADD2METHOD( link, false );
[$cpp]           }
#end
[$cpp]       }  

FIND

[$jav]       public List<$property.shortType> find${property.shortType}(${property.shortTarget} removal) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List result = new ArrayList();
[$jav]           for( $property.shortType link : ${fieldName} ) {
[$jav]               if (link.${other} == removal) result.add(link);
[$jav]           }
[$jav]           return result;
[$jav]       }
[$pyc]       def find${property.shortType}(self, removal):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           result = list()
[$pyc]           for link in self.${fieldName}:
[$pyc]               if link.${other} == removal: result.append(link)
[$pyc]           return result
[$pyc]
[$hdr]       virtual std::vector<${property.shortType}Ptr> find${property.shortType}(${property.shortTarget}Ptr removal);
[$cpp]       std::vector<${property.shortType}Ptr> ${PojoI}::find${property.shortType}(${property.shortTarget}Ptr removal) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> result;
[$cpp]           $cppType::iterator beg = begin${PropertyName}();
[$cpp]           $cppType::iterator end = end${PropertyName}();
[$cpp]           while (beg != end) {
[$cpp]               if ((*beg)->${other} == removal) result.push_back( *beg );
[$cpp]               ++beg;
[$cpp]           }
[$cpp]           return result;
[$cpp]       }  

REMOVE

#set( $removeLinkPredicate = "testRemove${property.shortTarget}From${PojoI}" )
[$cpp]
[$cpp]       struct $removeLinkPredicate {
[$cpp] 
[$cpp]         const ${property.shortType}Ptr t;
[$cpp]         const bool bothSides;
[$cpp]         ${removeLinkPredicate}(const ${property.shortType}Ptr n, const bool b) : t(n), bothSides(b) {}
[$cpp]         bool operator()(${property.shortType}Ptr const& o) {
[$cpp]            if (o == t) {
#if($bidir)
[$cpp]                if (bothSides && t->${other}->loaded){
[$cpp]                    ${property.shortTarget}Ptr::dynamicCast(o->${other})->remove${property.shortType}(t,false);
[$cpp]                }
#end
[$cpp]                return true;
[$cpp]            }
[$cpp]            return false;
[$cpp]         }
[$cpp]       }; 
[$cpp]

[$Ice]       void unlink${property.shortTarget}(${property.shortTarget} removal);
[$jav]       public void unlink${property.shortTarget}(${property.shortTarget} removal, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$property.shortType> toRemove = find${property.shortType}(removal);
[$jav]           Iterator<$property.shortType> it = toRemove.iterator();
[$jav]           while( it.hasNext() ){
[$jav]               remove${property.shortType}( it.next(), true );
[$jav]           }
[$jav]       }

[$Ice]       void remove${property.shortType}(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void remove${property.shortType}(${property.shortType} link, boolean bothSides, Ice.Current current  ) throws omero.UnloadedEntityException, omero.UnloadedCollectionException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( link );
#if($bidir)
[$jav]           if (bothSides && link.${other}.loaded) {
[$jav]               ((${property.shortTarget})link.${other}).remove${property.shortType}(link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def unlink${property.shortTarget}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           toRemove = self.find${property.shortType}(removal)
[$pyc]           for next in toRemove:
[$pyc]               self.remove${property.shortType}( next, True )
[$pyc]
[$pyc]       def remove${property.shortType}(self, link, bothSides, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self.${fieldName}.remove( link )
#if($bidir)
[$pyc]           if bothSides and link.${other}.loaded:
[$pyc]               link.${other}.remove${property.shortType}(link, False)
#end
[$pyc]
[$hdr]       virtual void unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       void ${PojoI}::unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> toRemove = find${property.shortType}(removal);
[$cpp]           $cppType::iterator beg = toRemove.begin();
[$cpp]           $cppType::iterator end = toRemove.end();
[$cpp]           while (beg != end) {
[$cpp]             remove${property.shortType}( *beg, true );
[$cpp]             ++beg;
[$cpp]           }
[$cpp]       }
[$hdr]       virtual void remove${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, $HDR_CURRENT);
[$cpp]       void ${PojoI}::remove${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           // predicate may do reverse side
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               ${removeLinkPredicate}(link, bothSides));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]       } 

##[$jav]    public Iterator<${property.shortTarget}> linked${property.shortTarget}Iterator() throws omero.UnloadedEntityException {
##[$jav]        errorIfUnloaded();
##[$jav]        if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
##[$jav]        return null;
##[$jav]    }
##[$hdr]    virtual std::vector<${property.shortTarget}Ptr>::iterator linked${property.shortTarget}Iterator();
##[$cpp]    std::vector<${property.shortTarget}Ptr>::iterator ${PojoI}::linked${property.shortTarget}Iterator() {
##[$cpp]        errorIfUnloaded();
##[$cpp]        std::vector<${property.shortTarget}Ptr>::iterator result;
##[$cpp]        return result;
##TODO------------
##[$cpp]    }



#end##End hasLink
#end##End hasSet
#end##End SPECIAL EXCEPTIONS

##################################################################
#end##FOREACH#####################################################
##################################################################

CLASS-LEVEL EXTRA METHODS BLOCK:
=====================================================================================================

#if($type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = ${prop.shortType} )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = ${prop.shortType} )
#end
#end##FOREACH

[$jav]       public void link(${parent} _parent, ${child} _child) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           setParent( _parent );
[$jav]           setChild( _child );
[$jav]       }
[$jav]       public ${parent} parent() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return (${parent}) parent;
[$jav]       }
[$jav]       public ${child} child() throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           return (${child}) child;
[$jav]       }
[$pyc]       def link(self, _parent, _child):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.setParent( _parent )
[$pyc]           self.setChild( _child )
[$pyc]
[$pyc]       def parent(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.parent
[$pyc]
[$pyc]       def child(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.child
[$pyc]
[$hdr]       virtual void link(${parent}Ptr parent, ${child}Ptr child);
[$hdr]       virtual ${parent}Ptr castParent();
[$hdr]       virtual ${child}Ptr castChild();
[$cpp]       void ${PojoI}::link(${parent}Ptr _parent, ${child}Ptr _child) {
[$cpp]           errorIfUnloaded();
[$cpp]           setParent( _parent );
[$cpp]           setChild(  _child  );
[$cpp]       }
[$cpp]       ${parent}Ptr ${PojoI}::castParent() {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${parent}Ptr::dynamicCast( parent );
[$cpp]       }
[$cpp]       ${child}Ptr ${PojoI}::castChild() {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${child}Ptr::dynamicCast( child );
[$cpp]       }
#end


COPYOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} to inject an "ome.model" object into this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public void copyObject(ome.util.Filterable model, ome.util.ModelMapper _mapper) {
[$jav]            omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]            if (model instanceof ${type.id}) {
[$jav]                ${type.id} source = (${type.id}) model;
[$jav]                this.loaded = source.isLoaded();
[$jav]                Long id = (Long) mapper.findTarget( source.getId() );
[$jav]                this.setId( id == null ? new omero.RLong() : new omero.RLong(id) );
[$jav]                // Following also copy counts, etc. if necessary
[$jav]                if (!source.isLoaded()) {
[$jav]                    this.unload();
[$jav]                } else {
#foreach($property in $type.propertyClosure)
[$jav]                    this.copy${property.nameCapped}( source, mapper );
#end##FOREACH
[$jav]               }
[$jav]             } else {
[$jav]                throw new IllegalArgumentException(
[$jav]                  "${type.shortname} cannot copy from " +
[$jav]                  (model==null ? "null" : model.getClass().getName()));
[$jav]             }
[$jav]       }

FILLOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} produce an "ome.model" object from this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public ome.util.Filterable fillObject(ome.util.ReverseModelMapper _mapper) {
[$jav]           omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]           $type.id target = new ${type.id}();
[$jav]           mapper.store(this, target);
[$jav]           if (!this.loaded) {
[$jav]             target.setId( id == null ? null : id.val );
[$jav]             target.unload();
[$jav]           } else {
[$jav]             omero.RLong id = this.getId();
[$jav]             target.setId( id == null ? null : Long.valueOf(id.val) ); // special property
[$jav]                // Following also copy counts, etc. if necessary
#foreach($property in $type.propertyClosure)
[$jav]                this.fill${property.nameCapped}( target, mapper );
#end##FOREACH
[$jav]           }
[$jav]           return target;
[$jav]         }

MISCELLANEOUS METHODS BLOCK:
=====================================================================================================

[$jav]     /**
[$jav]      * Casts (without warning) the given list to a list of
[$jav]      * the current type.
[$jav]      * @throws ClassCastException
[$jav]      */
[$jav]     @SuppressWarnings("unchecked") public static List<${PojoI}> cast(List list) { return list; }


END DECLARATION BLOCK:
=====================================================================================================

[$jav] }
[$hdr]  };
[$hdr]  typedef IceUtil::Handle<${PojoI}> ${PojoI}Ptr;
[$hdr]

[$cpp]}}
[$hdr]}}
[$hdr] #endif // ${POJOI}_H
[$ice]     };
[$ice]   };
[$ice] };
[$ice] #endif // ${POJO}_ICE
[$pyc] _omero_model.${PojoI} = ${PojoI}
#stop

