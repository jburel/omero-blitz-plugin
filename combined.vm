#*
 *   $Id$
 *
 *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 *#

Note: lines not prefixed with [...] will be omitted in the final product.
The other prefixes are used by blitz/build.xml to determine how this file
will be split. This is done because the individual velocity if/elseif's
and sets are nearly identical.

Here we turn off all prefixes except for ice.  Since <>I files are
concrete implementations, they should only be generated for concrete
classes. Capitalized versions will be turned on even for abstract classes.

#set( $ALL = "all" )
#set( $JAV = "jav" )
#set( $CPP = "cpp" )
#set( $HDR = "hdr" )
#set( $PYC = "pyc" )
#set( $ice = "ice" )
#set( $all = "all" )
#set( $jav = "jav" )
#set( $cpp = "cpp" )
#set( $hdr = "hdr" )
#set( $pyc = "pyc" )
#if($type.abstract)
#set( $all = "abs" )
#set( $jav = "abs" )
#set( $cpp = "abs" )
#set( $hdr = "abs" )
#set( $pyc = "abs" )
#end

Copyright notice added to all files:
[$pyc] """
[$ALL] /*
[$ALL]  *   Generated by blitz/templates/resouces/combined.vm
[$hdr]  *   See ../../README.h for information on these types.
[$ice]  *   See ../../README.ice for information on these types.
[$ALL]  *
[$ALL]  *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
[$ALL]  *   Use is subject to license terms supplied in LICENSE.txt
[$ALL]  *
[$ALL]  */
[$pyc] """

VARIABLES:
#set($Pojo  = "${type.shortname}")
#set($PojoI = "${Pojo}I")
#set($POJO  = "${Pojo.toUpperCase()}")
#set($POJOI = "${PojoI.toUpperCase()}")


DECLARATION BLOCK:

[$ice] #ifndef ${POJO}_ICE
[$ice] #define ${POJO}_ICE
[$hdr] #ifndef ${POJOI}_H
[$hdr] #define ${POJOI}_H

[$ice] \#include <omero/fwd.ice>
[$ice] \#include <omero/IObject.ice>
[$ice] \#include <omero/RTypes.ice>
#if( $type.superclass )
#set( $parent = $type.superclass.replaceFirst(".*ome.model..+?[.]","") )
[$ice] \#include <omero/model/${parent}.ice>
#set( $include = '\#include' )
#set( $importModify = '.replaceAll("^","[ice]").replaceAll(".*java.*","").replaceAll("import.*[.](.*?);","$include <omero/model/$1.ice>") ' )
$secondpassclassimports$importModify
#end
[$hdr] \#include <omero/ClientErrors.h>
[$hdr] \#include <omero/IObject.h>
[$hdr] \#include <omero/model/DetailsI.h>
[$hdr] \#include <omero/model/${Pojo}.h>
[$hdr] \#include <omero/ModelI.h>

[$ice] module omero {
[$ice]   module model {

[$jav] package omero.model;
[$jav] import  java.util.*;
[$jav] import  ome.conditions.*;
[$jav] public class ${PojoI} extends ${Pojo} 
[$jav]    implements ome.model.ModelBased {

Note how the whitespace for the python definitions is important.
[$pyc] import Ice
[$pyc] import omero_model_DetailsI
[$pyc] import omero_model_${Pojo}_ice
[$pyc] _omero = Ice.openModule("omero")
[$pyc] _omero_model = Ice.openModule("omero.model")
[$pyc] __name__ = "omero.model"

[$pyc] class ${PojoI}(_omero_model.$Pojo):
[$pyc]
[$hdr] namespace omero { 
[$hdr]   namespace model {
[$hdr]     class ${PojoI} : virtual public ${Pojo} { 

[$cpp] \#include <omero/model/${Pojo}I.h>
[$cpp] namespace omero { 
[$cpp]   namespace model {

[$hdr]     protected:

GENERATOR:

[$pyc]       class ${Pojo}I_generator:
[$pyc]           def __iter__(self):
[$pyc]               return self
[$pyc]           def next(self):
[$pyc]               return ${Pojo}I()
[$pyc]
[$pyc]       @classmethod
[$pyc]       def generator(cls):
[$pyc]           return cls.${Pojo}I_generator()
[$pyc]

INTERNAL METHODS:

[$hdr]       void errorIfUnloaded();
[$cpp]       void ${PojoI}::errorIfUnloaded()
[$cpp]       {
[$cpp]         if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
[$cpp]       }
[$jav]       protected void errorIfUnloaded() throws omero.UnloadedEntityException
[$jav]       {
[$jav]         if ( ! loaded ) throw new omero.UnloadedEntityException("Object unloaded:"+this);
[$jav]       }
[$pyc]       def errorIfUnloaded(self):
[$pyc]           if not self.loaded:
[$pyc]               raise _omero.UnloadedEntityException("Object unloaded:"+str(self))
[$pyc]
[$hdr]       void throwNullCollectionException(std::string propertyName);
[$cpp]       void ${PojoI}::throwNullCollectionException(std::string propertyName)
[$cpp]       {
[$cpp]         std::string s = "Error updating collection:" + propertyName +"\n"+
[$cpp]         "Collection is currently null. This can be seen\n"+
[$cpp]         "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$cpp]         "that this collection was unloaded. Please refresh this object\n"+
[$cpp]         "in order to update this collection.\n";
[$cpp]         throw omero::UnloadedCollectionException(
[$cpp]            __FILE__,__LINE__,s.c_str());
[$cpp]       }
[$jav]       protected void throwNullCollectionException(String propertyName) throws omero.UnloadedCollectionException
[$jav]       {
[$jav]          throw new omero.UnloadedCollectionException(
[$jav]            "Error updating collection:" + propertyName +"\n"+
[$jav]            "Collection is currently null. This can be seen\n"+
[$jav]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$jav]            "that this collection was unloaded. Please refresh this object\n"+
[$jav]            "in order to update this collection.\n"
[$jav]            );
[$jav]       }
[$pyc]       def throwNullCollectionException(self,propertyName):
[$pyc]           raise omero.UnloadedEntityException(""+
[$pyc]           "Error updating collection:" + propertyName +"\n"+
[$pyc]           "Collection is currently null. This can be seen\n" +
[$pyc]           "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$pyc]           "that this collection was unloaded. Please refresh this object\n"+
[$pyc]           "in order to update this collection.\n")
[$pyc]
DESTRUCTOR BLOCK:

[$hdr]       virtual ~${PojoI}();
[$cpp]     ${PojoI}::~${PojoI}() {}

[$hdr]     public:


DEFAULT CONSTRUCTOR BLOCK:


[$hdr]       ${PojoI}();
[$jav]       public ${PojoI}() {
[$cpp]       ${PojoI}::${PojoI}() : ${Pojo}() {
[$cpp]           loaded = true;
[$cpp]           toggleCollectionsLoaded(true);
[$cpp]           details = new omero::model::DetailsI();
[$jav]           loaded = true;
[$jav]           toggleCollectionsLoaded(true);
[$jav]           details = new omero.model.DetailsI();
[$jav]       }
[$cpp]       }

Python combines the two constructors. See below for a comparison.
[$pyc]       def __init__(self,id = None,loaded = True):
[$pyc]           super(${Pojo}I, self).__init__()
[$pyc]           self.id = id
[$pyc]           self.loaded = loaded
[$pyc]           if self.loaded:
[$pyc]              self.details = _omero_model.DetailsI()
[$pyc]              self.toggleCollectionsLoaded(True)
[$pyc]
TOGGLE COLLECTIONS:

[$jav]       public void toggleCollectionsLoaded(boolean load) {
[$hdr]       virtual void toggleCollectionsLoaded(bool load);
[$cpp]    void ${PojoI}::toggleCollectionsLoaded(bool load) {
[$pyc]       def toggleCollectionsLoaded(self,load):
#foreach( $property in $type.classProperties)
#set(     $PropertyName = $property.nameCapped )
#set(     $javaType = $property.type)
#set(     $seqName = "${Pojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set($genericType = $property.type)
#set($genericType = $genericType.replaceFirst("ome.model..+?[.]","omero::model::"))
#set($genericTypeC = "${genericType.replaceAll('[.]','::')}")

Here we don't have to keep up with the type (set/list)
since all collections are lists in ice.

#if(      $fulltype.contains("byte[]"))
[$ice]     sequence<byte> ${seqName};

#elseif(  $property.one2Many )

[$ice]     ["java:type:java.util.ArrayList"] sequence<$genericTypeC> ${seqName};

[$jav]           if (load) {
[$jav]               ${property.name} = new ArrayList();
[$jav]               ${property.name}Loaded = true;
[$jav]           } else {
[$jav]               ${property.name} = null;
[$jav]               ${property.name}Loaded = false;
[$jav]           }
[$cpp]           if (load) {
[$cpp]               ${property.name} = ${seqName}();
[$cpp]               ${property.name}Loaded = true;
[$cpp]           } else {
[$cpp]               ${property.name} = (${seqName})0;
[$cpp]               ${property.name}Loaded = false;
[$cpp]           }
[$pyc]           if load:
[$pyc]               self.${property.name} = []
[$pyc]               self.${property.name}Loaded = True;
[$pyc]           else:
[$pyc]               self.${property.name} = []
[$pyc]               self.${property.name}Loaded = False;
[$pyc]
#end
#end##FOREACH
[$jav]    }
[$cpp]    }
##               In case there are no collections
[$pyc]           pass
[$pyc]

ICE CLASS:

Calculate inheritance. This is done here because sequences must first be defined.

#set( $base = "omero::model::IObject" )
#set( $extendsDeclaration = $base )
#if(  $type.superclass )
#set( $extendsDeclaration = $type.superclass.replaceFirst("ome.model..+?[.]","omero::model::" ) )
#end

[$ice]     class ${type.shortname}
[$ice]     extends $extendsDeclaration
[$ice]     {

UNLOADED CONSTRUCTOR BLOCK:

[$hdr]       ${PojoI}(omero::RLongPtr idPtr, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(omero::RLongPtr idPtr, bool isLoaded) : ${Pojo}() {
[$cpp]      id = idPtr;
[$cpp]      loaded = isLoaded;
[$cpp]      if (loaded) details = new omero::model::DetailsI(); 
[$cpp]      toggleCollectionsLoaded(isLoaded);
[$cpp]    }
[$jav]    public ${PojoI}(long id, boolean loaded) {
[$jav]      this.id = new omero.RLong(id);
[$jav]      this.loaded = loaded; 
[$jav]      if (loaded) details = new omero.model.DetailsI();
[$jav]    }
See single Python constructor above.

UNLOAD BLOCK:

[$jav]       public void unload(Ice.Current current) {
[$hdr]       virtual void unload(const Ice::Current& current = Ice::Current());
[$cpp]       void ${PojoI}::unload(const Ice::Current& current) {
[$pyc]       def unload(self, current = Ice.Current()):
[$pyc]           self.loaded = False
[$jav]           loaded = false;
[$cpp]           loaded = false;
## Properties not in foreach
## [$jav]           unloadDetails( );
## [$cpp]           unloadDetails( );
## [$pyc]           self.unloadDetails( )
#foreach($property in $type.propertyClosure)
#if(!$clazz.identifierProperty.equals($property))
#set( $PropertyName = $property.nameCapped )
[$jav]           unload${PropertyName}( );
[$cpp]           unload${PropertyName}( );
[$pyc]           self.unload${PropertyName}( )
#end
#end##FOREACH
[$pyc]
[$jav]    }
[$cpp]    }

SPECIAL METHODS:
Id acccesors copied from other accessors below.

[$jav]       public Long getId() {
[$jav]           return id == null ? null : id.val;
[$jav]       }
[$jav]
[$jav]       public void setId( Long id ) {
[$jav]           this.id = (id == null) ? null : new omero.RLong(id);
[$jav]       }

[$hdr]       virtual omero::RLongPtr getId();
[$hdr]       virtual void setId( omero::RLongPtr id );

[$cpp]       omero::RLongPtr ${PojoI}::getId() {
[$cpp]           return id;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setId(omero::RLongPtr _id) {
[$cpp]           id = _id;
[$cpp]       }

[$pyc]       def getId(self):
[$pyc]           return self.id
[$pyc]
[$pyc]       def setId(self, _id):
[$pyc]           self.id = _id
[$pyc]
Doing unloadedPython as a method because of the multi-line restriction. See below.
[$pyc]       def checkUnloadedProperty(self, value, loadedField):
[$pyc]           if value == None:
[$pyc]               self.__dict__[loadedField] = False
[$pyc]           else:
[$pyc]               self.__dict__[loadedField] = True
[$pyc]
###########################################################################
#foreach($property in $type.propertyClosure)#############
###########################################################################

ACCESSORS BLOCK:

These mappings are from HibernateTypes-->IceTypes

Ice properties should only be defined once (not in every subclass, obviously).
However, because of Ice's inheritance structure, we are here using
propertyClosure which gives us superclass fields. These must be filtered
in the [Ice] sections below, but not for all others.

[$hdr]
[$hdr]       //
[$hdr]       //  ${Pojo}.${property.name}
[$hdr]       //

#set( $definedIn = "nothere" )
#foreach( $p2 in $type.classProperties )
#if( $p2.name.equals($property.name) )
#set( $definedIn = "here" )
#end
#end
#set($Ice = "ice" )
#if( $definedIn.startsWith("not") )
#set($Ice = "NOT" )
#end

## UNIFY THESE
#set( $field = $property.name )
#set( $PropertyName = $property.nameCapped)
#set( $FIELD = ${field.toUpperCase()} )
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $open = " " )
#set( $close= " " )
#set( $prefix=" " )
#set( $suffix=" " )
#set( $unloadedJava=" " )
#set( $unloadedCpp=" " )
#set( $unloadedPython="pass" )
## Here we are taking the pojo name from the ST of the property, rather than the
## current ST in order to handle subclasses wrt. links. This may need to be done for
## every property right after the foreach.
#set( $truePojo = "${property.getST().shortname}" )
#set( $seqName = "${truePojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set( $propLoaded = "${property.Name}Loaded" )

## TODO use empty List or null?
## #684 Mapping all sets to lists.
#if( $property.one2Many )##JAVA_TYPE
#set( $javaType = "java.util.List" )
#set( $getter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( this.$property.name ) " )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( $property.name )" )
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} != ($cppType) 0) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )
#set( $unloadedPython = "self.checkUnloadedProperty(_${property.name},'${propLoaded}')" )

#elseif( $javaType.startsWith("ome"))
#set( $javaType = "omero.model.${shortType}" )
#set( $getter = "(omero.model.${shortType}) this.$property.name" )
#set( $setter = "${property.name}")
#set( $cppType = "omero::model::${shortType}Ptr" )

#elseif( $javaType.startsWith("IObject"))
#set( $javaType = "omero.model.IObject")
#set( $getter = "(omero.model.IObject) this.$property.name" )
#set( $setter = "${property.name}")
#set( $cppType = "omero::model::IObjectPtr")

#elseif( $javaType.startsWith("java.lang.Boolean"))
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RBool(${property.name}) ")
#set( $cppType   = "omero::RBoolPtr" )

#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RInt(${property.name}) ")
#set( $cppType   = "omero::RIntPtr" )

#elseif( $javaType.startsWith("java.lang.Long"))
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RLong(${property.name}) ")
#set( $cppType   = "omero::RLongPtr" )

#elseif( $javaType.startsWith("java.lang.Double"))
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RDouble(${property.name}) ")
#set( $cppType   = "omero::RDoublePtr" )

#elseif( $javaType.startsWith("java.lang.Float"))
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RFloat(${property.name}) ")
#set( $cppType   = "omero::RFloatPtr" )

#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "Long" )
#set( $getter   = "new Long(this.$property.name)" )
#set( $setter = "(${property.name} == null) ? 0 : this.$property.name == ${property.name}.longValue()")
#set( $cppType = "long" )

#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $getter = "${property.name} == null ? null : new java.sql.Timestamp( ${property.name}.val )" )
#set( $setter = "${property.name} == null ? null : new omero.RTime(${property.name}.getTime())");
#set( $cppType = "omero::RTimePtr" )

#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $getter = "${property.name} == null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? null : new omero.RString(${property.name}) ")
#set( $cppType = "omero::RStringPtr" )

#else
[$all]...ERROR...$javaType unknown.

#end##JAVA_TYPE

ICE BLOCK:

// $property
#if($field.equals("id"))
             // Id in IObject
#elseif($field.equals("details"))
             // Details in IObject
#elseif($field.equals("version"))
#if($extendsDeclaration.equals($base))
             // Version in superclass
[$Ice]       omero::RInt version;
#end
#elseif( ${shortType} == "String")
[$Ice]       omero::RString ${property.name};
#elseif( ${shortType} == "Boolean" )
[$Ice]       omero::RBool ${property.name};
#elseif ( ${shortType} == "Double" )
[$Ice]       omero::RDouble ${property.name};
#elseif ( ${shortType} == "Float" )
[$Ice]       omero::RFloat ${property.name};
#elseif( ${shortType} == "Integer")
[$Ice]       omero::RInt ${property.name};
#elseif ( ${shortType} == "Long" )
[$Ice]       omero::RLong ${property.name};
#elseif( $property.one2Many )
[$Ice]       $seqName ${property.name};
[$Ice]       bool ${property.name}Loaded;
#elseif ($javaType.startsWith("ome") )## Had to be moved before "*Map" rule
[$Ice]       omero::model::${shortType} ${property.name};
#elseif ($javaType.equals("IObject"))## Special case of the previous
[$Ice]       omero::model::IObject ${property.name};
#elseif ($shortType.endsWith("Map") )
[$Ice]       dictionary ${property.name};
#elseif ($javaType.equals("java.sql.Timestamp"))
[$Ice]       omero::RTime ${property.name};
#elseif ($javaType.equals("long")) ## From Permissions
[$Ice]       long ${field};
#else
[$Ice]       ERROR ===========> Unknown type (${javaType})
#end // End type


ASSOCIATION TYPES BLOCK:

#set( $hasSet  = false)
#set( $hasLink = false )
#set( $hasSet  = $property.one2Many)
#if( $property.class.name.equals("ome.dsl.ChildLink") || $property.class.name.equals("ome.dsl.ParentLink"))
#set( $hasLink = true )
#end

#set( $access = "protected" )
#set( $unloadIfIsSet = "${property.Name}Loaded = false;")
#if( !$hasSet && !$hasLink)
#set( $access = "public" )
#set( $unloadIfIsSet = "");
#end

Unload

[$jav]       public void unload${PropertyName}() {
[$jav]           ${unloadIfIsSet}
[$jav]           ${property.name} = null;
[$jav]       }
[$hdr]       virtual void unload${PropertyName}();
[$cpp]       void ${Pojo}I::unload${PropertyName}() {
[$cpp]           ${unloadIfIsSet}
[$cpp]           ${property.name} = ($cppType) 0;
[$cpp]       }
[$pyc]       def unload${PropertyName}(self):
[$pyc]           self.${property.Name}Loaded = False
[$pyc]           self.${property.name} = None;
[$pyc]
Original accessors: will have their visibility reduced if
the special set methods are added.

[$jav]       $access $javaType get${property.nameCapped}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return $getter;
[$jav]       }
[$jav]
[$jav]       $access void set${PropertyName}($javaType $property.Name) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           this.$property.Name = $setter;
[$jav]           $unloadedJava
[$jav]       }

#if($access == "protected" )
[$hdr]     protected:
#end
[$hdr]       virtual $cppType get${property.nameCapped}();
[$hdr]       virtual void set${PropertyName}($cppType _$property.Name);
#if($access == "protected" )
[$hdr]     public:
#end

[$cpp]       $cppType ${PojoI}::get${property.nameCapped}() {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${open}${property.name}${close};
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::set${PropertyName}($cppType _$property.Name) {
[$cpp]           errorIfUnloaded();
[$cpp]           $property.Name = $!{prefix}_${property.Name}$!{suffix};
[$cpp]           $unloadedCpp
[$cpp]       }

[$pyc]       def get${property.nameCapped}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.${property.name}
[$pyc]
[$pyc]       def set${PropertyName}(self, _${property.name}):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.${property.Name} = _${property.name}
[$pyc]           $unloadedPython
[$pyc]
One-to-many extras:

#if( $hasSet || $hasLink )

[$jav]       public boolean is${PropertyName}Loaded() {
[$jav]           return ${propLoaded};
[$jav]       }
[$hdr]       virtual bool is${PropertyName}Loaded();
[$cpp]       bool ${PojoI}::is${PropertyName}Loaded( ) {
[$cpp]           return ${propLoaded};
[$cpp]       }
[$pyc]       def is${PropertyName}Loaded(self):
[$pyc]           return self.${propLoaded}
[$pyc]
[$jav]       public long sizeOf${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$jav]           return ${property.name}.size();
[$jav]       }
[$hdr]       virtual Ice::Long sizeOf${PropertyName}();
[$cpp]       Ice::Long ${PojoI}::sizeOf${PropertyName}( ) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]           return ${property.name}.size();
[$cpp]       }
[$pyc]       def sizeOf${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${property.name}")
[$pyc]           return len(self.${property.name})
[$pyc]
[$jav]       public Iterator iterate${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$jav]           return ${property.name}.iterator();
[$jav]       }
[$hdr]       virtual $cppType::iterator begin${PropertyName}();
[$hdr]       virtual $cppType::iterator end${PropertyName}();
[$cpp]       $cppType::iterator ${PojoI}::begin${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]           return ${property.name}.begin();
[$cpp]       }
[$cpp]       $cppType::iterator ${PojoI}::end${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]           return ${property.name}.end();
[$cpp]       } 
[$pyc]       def iterate${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${property.name}")
[$pyc]           return iter(self.${property.name})
[$pyc]

[$jav]       public List<$javaType> copy${PropertyName}() throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$jav]           List<$javaType> result = new ArrayList(${property.name});
[$jav]           return result;
[$jav]       }
[$pyc]       def copy${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${property.name}")
[$pyc]           return list(self.${property.name})
[$pyc]
             Here we don't have a vector<$cppType> since the type is typedef'd
[$hdr]       virtual $cppType copy${PropertyName}();
[$cpp]       $cppType ${PojoI}::copy${PropertyName}() {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]           $cppType result(${property.name}.size());
[$cpp]           std::copy(${property.name}.begin(), ${property.name}.end(), result.begin());
[$cpp]           return result;
[$cpp]       }

#end


------------------------------------------------------------
Because of the ice inheritance hierarchy, we must use direct
field access on several methods below.
------------------------------------------------------------

Set modifications:

#if( $hasSet )
#set( $inverse = $property.inverse )
#set( $inverselength = $inverse.length() )
#set( $Inverse = "${inverse.substring(0,1).toUpperCase()}${inverse.substring(1,$inverselength)}" )

add single

[$jav]       public void add${property.shortType}(${property.shortType} target) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.name}.add( target );
[$jav]           target.$inverse = this;
[$jav]       }
[$pyc]       def add${property.shortType}(self,target):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           self.${property.name}.append( target );
[$pyc]           target.$inverse = self;
[$pyc]
[$hdr]       virtual void add${property.shortType}(${property.shortType}Ptr target);
[$cpp]       void ${PojoI}::add${property.shortType}(${property.shortType}Ptr target) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           ${property.name}.push_back( target );
[$cpp]           target->$inverse = this;
[$cpp]       }

add set

[$jav]       public void add${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.name}.addAll( targets );
[$jav]           for( ${property.shortType} target : targets) {
[$jav]               target.$inverse = this;
[$jav]           }
[$jav]       }
[$pyc]       def add${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if  not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           self.${property.name}.extend( targets )
[$pyc]           for target in targets:
[$pyc]               target.$inverse = self
[$pyc]
[$hdr]       virtual void add${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::add${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           $cppType::iterator loc = ${property.name}.end();
[$cpp]           $cppType::iterator beg = targets.begin(); 
[$cpp]           $cppType::iterator end = targets.end(); 
[$cpp]           ${property.name}.insert(loc,beg,end);
[$cpp]           for ($cppType::iterator it = targets.begin(); it != targets.end(); ++it) {
[$cpp]               ${property.shortType}Ptr target = *it;
[$cpp]               target->$inverse = this;
[$cpp]           }
[$cpp]       }

remove single

#set( $removePredicate = "testRemove${property.shortType}From${PojoI}" )
[$cpp]       struct $removePredicate
[$cpp]       {
[$cpp]           const ${property.shortType}Ptr t;
[$cpp]           ${removePredicate}(const ${property.shortType}Ptr n) : t(n) {}
[$cpp]           bool operator()(${property.shortType}Ptr const& o) {
[$cpp]               return o == t;
[$cpp]           }
[$cpp]       };

[$jav]       public void remove${property.shortType}(${property.shortType} target) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.name}.remove( target );
[$jav]           target.$inverse = null;
[$jav]       }
[$pyc]       def remove${property.shortType}(self, target):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           self.${property.name}.remove( target )
[$pyc]           target.$inverse = None
[$pyc]
[$hdr]       virtual void remove${property.shortType}(${property.shortType}Ptr target);
[$cpp]       void ${PojoI}::remove${property.shortType}(${property.shortType}Ptr target) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${property.name}.begin(),
[$cpp]               ${property.name}.end(),
[$cpp]               ${removePredicate}(target));
[$cpp]           ${property.name}.erase(it,${property.name}.end());
[$cpp]           target->$inverse = (${PojoI}Ptr)0;
[$cpp]       } 

remove multiple

#set( $removeSetPredicate = "testRemove${property.shortType}SetFrom${PojoI}" )
[$cpp]       struct ${removeSetPredicate}
[$cpp]       {
[$cpp]           const ${cppType} t;
[$cpp]           ${removeSetPredicate}(const ${cppType} n) : t(n) {}
[$cpp]           bool operator()(${property.shortType}Ptr const& o) {
[$cpp]               return std::find(t.begin(), t.end(), o) != t.end();
[$cpp]           }
[$cpp]       };    

[$jav]       public void remove${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           for( ${property.shortType} elt : targets) {
[$jav]               elt.$inverse = null;
[$jav]               ${property.name}.remove( elt );
[$jav]           }
[$jav]       }
[$pyc]       def remove${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           for elt in targets:
[$pyc]               elt.$inverse = None
[$pyc]               self.${property.name}.remove( elt )
[$pyc]
[$hdr]       virtual void remove${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::remove${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           ${cppType}::iterator end = ${property.name}.end(); 
[$cpp]           ${cppType}::iterator removed = std::remove_if(
[$cpp]               ${property.name}.begin(), end,
[$cpp]               $removeSetPredicate(targets));
[$cpp]           ${cppType}::iterator beg(removed);
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->$inverse = (${PojoI}Ptr)0; 
[$cpp]           }
[$cpp]           ${property.name}.erase(removed,end);
[$cpp]       }   

clear

[$jav]       public void clear${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           for( ${property.shortType} elt : (Collection<${property.shortType}>)${property.name}) {
[$jav]               elt.$inverse = null;
[$jav]           }
[$jav]           ${property.name}.clear();
[$jav]       }
[$pyc]       def clear${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           for elt in self.${property.name}:
[$pyc]               elt.$inverse = None
[$pyc]           self.${property.name} = list()
[$pyc]
[$hdr]       virtual void clear${PropertyName}();
[$cpp]       void ${PojoI}::clear${PropertyName}() {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           $cppType::iterator beg = ${property.name}.begin();
[$cpp]           $cppType::iterator end = ${property.name}.end();
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->$inverse = (${PojoI}Ptr)0;
[$cpp]           }
[$cpp]           ${property.name}.clear();
[$cpp]       }

Link Modifications

#if( $hasLink )

Here our "elements" from the above are the links which themselves
have linked elements.

#if($property.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "parent" )
#set( $other = "child" )
#elseif($property.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "child" )
#set( $other = "parent" )
#end
#set( $bidir = $property.bidirectional )
#set( $pyorder = $order.replaceAll("this","self"))

ADD

[$jav]       public void link${property.shortTarget}(${property.shortTarget} addition) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.shortType}I link = new ${property.shortType}I();
[$jav]           link.link( ${order} );
[$jav]           add${property.shortType}( link, true );
[$jav]       }
[$pyc]       def link${property.shortTarget}(self, addition):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           link = _omero_model.${property.shortType}I()
[$pyc]           link.link( ${pyorder} );
[$pyc]           self.add${property.shortType}( link, True )
[$pyc]
[$hdr]       virtual void link${property.shortTarget}(const ${property.shortTarget}Ptr& addition);
[$cpp]       void ${PojoI}::link${property.shortTarget}(const ${property.shortTarget}Ptr& addition) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           ${property.shortType}IPtr link = new ${property.shortType}I();
[$cpp]           link->link( ${order} );
[$cpp]           add${property.shortType}( link, true );
[$cpp]       }  

TODO: do we need to do link.parent = ...;

#if(!$type.superclass)
[$ice]       void add${property.shortType}(omero::model::${property.shortType} link, bool bothSides);
#end
[$jav]       public void add${property.shortType}(${property.shortType} link, boolean bothSides, Ice.Current current) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.name}.add( link );
#if($bidir) 
TODO: Should we check for nulls in other?
[$jav]           if (bothSides && link.${other}.loaded ) {
[$jav]               ((${property.shortTarget})link.${other}).add${property.shortType}( link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def add${property.shortType}(self, link, bothSides):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           self.${property.name}.append( link )
#if($bidir) 
[$pyc]           if bothSides and link.${other}.loaded:
[$pyc]               link.${other}.add${property.shortType}( link, False )
#end
[$pyc]
[$hdr]       virtual void add${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current = Ice::Current());
[$cpp]       void ${PojoI}::add${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           ${property.name}.push_back( link );
#if($bidir)
[$cpp]           if (bothSides && link->${other}->loaded ) {
[$cpp]               ${property.shortTarget}Ptr::dynamicCast(link->${other})->add${property.shortType}( link, false );
[$cpp]           }
#end
[$cpp]       }  

FIND

[$jav]       public List<$property.shortType> find${property.shortType}(${property.shortTarget} removal) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           List result = new ArrayList();
[$jav]           for( $property.shortType link : ${property.name} ) {
[$jav]               if (link.${other} == removal) result.add(link);
[$jav]           }
[$jav]           return result;
[$jav]       }
[$pyc]       def find${property.shortType}(self, removal):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           result = list()
[$pyc]           for link in self.${property.name}:
[$pyc]               if link.${other} == removal: result.append(link)
[$pyc]           return result
[$pyc]
[$hdr]       virtual std::vector<${property.shortType}Ptr> find${property.shortType}(${property.shortTarget}Ptr removal);
[$cpp]       std::vector<${property.shortType}Ptr> ${PojoI}::find${property.shortType}(${property.shortTarget}Ptr removal) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           std::vector<${property.shortType}Ptr> result;
[$cpp]           $cppType::iterator beg = begin${PropertyName}();
[$cpp]           $cppType::iterator end = end${PropertyName}();
[$cpp]           while (beg != end) {
[$cpp]               if ((*beg)->${other} == removal) result.push_back( *beg );
[$cpp]               ++beg;
[$cpp]           }
[$cpp]           return result;
[$cpp]       }  

REMOVE

#set( $removeLinkPredicate = "testRemove${property.shortTarget}From${PojoI}" )
[$cpp]
[$cpp]       struct $removeLinkPredicate {
[$cpp] 
[$cpp]         const ${property.shortType}Ptr t;
[$cpp]         const bool bothSides;
[$cpp]         ${removeLinkPredicate}(const ${property.shortType}Ptr n, const bool b) : t(n), bothSides(b) {}
[$cpp]         bool operator()(${property.shortType}Ptr const& o) {
[$cpp]            if (o == t) {
#if($bidir)
[$cpp]                if (bothSides && t->${other}->loaded){
[$cpp]                    ${property.shortTarget}Ptr::dynamicCast(o->${other})->remove${property.shortType}(t,false);
[$cpp]                }
#end
[$cpp]                return true;
[$cpp]            }
[$cpp]            return false;
[$cpp]         }
[$cpp]       }; 
[$cpp]

[$jav]       public void unlink${property.shortTarget}(${property.shortTarget} removal) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           List<$property.shortType> toRemove = find${property.shortType}(removal);
[$jav]           Iterator<$property.shortType> it = toRemove.iterator();
[$jav]           while( it.hasNext() ){
[$jav]               remove${property.shortType}( it.next(), true );
[$jav]           }
[$jav]       }

#if(!$type.superclass)
[$ice]       void remove${property.shortType}(omero::model::${property.shortType} link, bool bothSides);
#end
[$jav]       public void remove${property.shortType}(${property.shortType} link, boolean bothSides, Ice.Current current  ) throws omero.UnloadedEntityException, omero.UnloadedCollectionException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]           ${property.name}.remove( link );
#if($bidir)
[$jav]           if (bothSides && link.${other}.loaded) {
[$jav]               ((${property.shortTarget})link.${other}).remove${property.shortType}(link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def unlink${property.shortTarget}(self, removal):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           toRemove = self.find${property.shortType}(removal)
[$pyc]           for next in toRemove:
[$pyc]               self.remove${property.shortType}( next, True )
[$pyc]
[$pyc]       def remove${property.shortType}(self, link, bothSides ):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           self.${property.name}.remove( link )
#if($bidir)
[$pyc]           if bothSides and link.${other}.loaded:
[$pyc]               link.${other}.remove${property.shortType}(link, False)
#end
[$pyc]
[$hdr]       virtual void unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal);
[$cpp]       void ${PojoI}::unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           std::vector<${property.shortType}Ptr> toRemove = find${property.shortType}(removal);
[$cpp]           $cppType::iterator beg = toRemove.begin();
[$cpp]           $cppType::iterator end = toRemove.end();
[$cpp]           while (beg != end) {
[$cpp]             remove${property.shortType}( *beg, true );
[$cpp]             ++beg;
[$cpp]           }
[$cpp]       }
[$hdr]       virtual void remove${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current = Ice::Current());
[$cpp]       void ${PojoI}::remove${property.shortType}(const ${property.shortType}Ptr& link, bool bothSides, const Ice::Current& current) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]           // predicate may do reverse side
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${property.name}.begin(),
[$cpp]               ${property.name}.end(),
[$cpp]               ${removeLinkPredicate}(link, bothSides));
[$cpp]           ${property.name}.erase(it,${property.name}.end());
[$cpp]       } 

##[$jav]    public Iterator<${property.shortTarget}> linked${property.shortTarget}Iterator() throws omero.UnloadedEntityException {
##[$jav]        errorIfUnloaded();
##[$jav]        if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
##[$jav]        return null;
##[$jav]    }
##[$hdr]    virtual std::vector<${property.shortTarget}Ptr>::iterator linked${property.shortTarget}Iterator();
##[$cpp]    std::vector<${property.shortTarget}Ptr>::iterator ${PojoI}::linked${property.shortTarget}Iterator() {
##[$cpp]        errorIfUnloaded();
##[$cpp]        std::vector<${property.shortTarget}Ptr>::iterator result;
##[$cpp]        return result;
##TODO------------
##[$cpp]    }



#end##End hasLink
#end##End hasSet

##################################################################
#end##FOREACH#####################################################
##################################################################

CLASS-LEVEL EXTRA METHODS:

#if($type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = ${prop.shortType} )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = ${prop.shortType} )
#end
#end##FOREACH

[$jav]       public void link(${parent} _parent, ${child} _child) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           setParent( _parent );
[$jav]           setChild( _child );
[$jav]       }
[$jav]       public ${parent} parent() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return (${parent}) parent;
[$jav]       }
[$jav]       public ${child} child() throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           return (${child}) child;
[$jav]       }
[$pyc]       def link(self, _parent, _child):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.setParent( _parent )
[$pyc]           self.setChild( _child )
[$pyc]
[$pyc]       def parent(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.parent
[$pyc]
[$pyc]       def child(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self.child
[$pyc]
[$hdr]       virtual void link(${parent}Ptr parent, ${child}Ptr child);
[$hdr]       virtual ${parent}Ptr castParent();
[$hdr]       virtual ${child}Ptr castChild();
[$cpp]       void ${PojoI}::link(${parent}Ptr _parent, ${child}Ptr _child) {
[$cpp]           errorIfUnloaded();
[$cpp]           setParent( _parent );
[$cpp]           setChild(  _child  );
[$cpp]       }
[$cpp]       ${parent}Ptr ${PojoI}::castParent() {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${parent}Ptr::dynamicCast( parent );
[$cpp]       }
[$cpp]       ${child}Ptr ${PojoI}::castChild() {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${child}Ptr::dynamicCast( child );
[$cpp]       }
#end


COPYOBJECT BLOCK:

[$jav]       public void copyObject(ome.util.Filterable model, ome.util.ModelMapper _mapper) {
[$jav]            omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]            if (model instanceof ${type.id}) {
[$jav]                ${type.id} source = (${type.id}) model;
[$jav]                this.loaded = source.isLoaded();
[$jav]                this.setId( (Long) mapper.findTarget( source.getId() ));
## Properties not in foreach
## [$jav]                if (this.loaded) this.setDetails( (omero.model.Details) mapper.findTarget( source.getDetails() ));
#foreach($property in $type.propertyClosure)
#set( $PropertyName = $property.nameCapped )
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $method = "source.get$PropertyName()" )

 TODO: Currently the findTarget methods have separate names.
 Instead there should be a cast to guarantee that the right
 method is invoked.

#set( $findMethod = "Target" )

 All properties other than id must be "guarded" to prevent
 UnloadedEntityExceptions.

#set( $guard  = "if (this.loaded) " )
#if($clazz.identifierProperty.equals($property))
#set( $guard  = "" )
#end

#if( $type.id.equals("ome.model.internal.Permissions") )
#set( $javaType = "Long" )
#set( $method = "ome.util.Utils.internalForm(source)" )
#elseif( $property.one2Many )
## See ticket:684
## If this is the case, we can't use the accessor and have to use a generated method
#set( $javaType = "java.util.List" )
#set( $method = "(Collection) source.retrieve(${type.id}.${PropertyName.toUpperCase()})" )
#set( $findMethod = "Collection")
#elseif( $javaType.startsWith("ome") )
#set( $javaType = "omero.model.${shortType}" )
#elseif( $javaType.startsWith("IObject") )
#set( $javaType = "omero.model.IObject" )
#elseif( $javaType.startsWith("long"))
#set( $javaType = "Long")
#elseif( $javaType.startsWith("java.util.Map") )
#set( $findMethod = "Map" )
#end

[$jav]              $guard this.set${PropertyName}(($javaType) mapper.find${findMethod}($method));

#end##FOREACH

[$jav]       } else {
[$jav]                throw new IllegalArgumentException(
[$jav]                  "${type.shortname} cannot copy from " +
[$jav]                  (model==null ? "null" : model.getClass().getName()));
[$jav]       }
[$jav]       }

FILLOBJECT BLOCK:

[$jav]       public ome.util.Filterable fillObject(ome.util.ReverseModelMapper _mapper) {
[$jav]           omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]           $type.id target = new ${type.id}();
[$jav]           mapper.store(this, target);
[$jav]           if (!this.loaded) {
[$jav]             target.setId( id == null ? null : id.val );
[$jav]             target.unload();
[$jav]           } else {
[$jav]             target.setId( this.getId() ); // special property
## Properties not in foreach
## [$jav]             target.setDetails( (ome.model.internal.Details) mapper.reverse( (ome.model.ModelBased) this.getDetails() ) );
#foreach($property in $type.propertyClosure)
#set( $PropertyName = $property.nameCapped )
#set( $fieldType = $property.fieldType.replaceAll("[<].*[>]",""))
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $FIELD = "${type.id}.${PropertyName.toUpperCase()}" )
#set( $propLoaded = "${property.Name}Loaded" )

#if( $property.name.equals("details"))
[$jav]             target.getDetails().copy( (${property.type}) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );
#elseif( $type.id.equals("ome.model.internal.Permissions") )
[$jav]             target = ome.util.Utils.toPermissions((Long)this.getPerm1());

#elseif( $property.one2Many )
## If this is the case, we can't use the accessor and have to use a generated method

[$jav]             if (this.${propLoaded}) {

ticket:684 This is necessary to map back and forth from sets.
[$jav]               target.putAt( $FIELD, mapper.reverse( this.get${PropertyName}(), ${fieldType}.class ));
[$jav]             } else {
[$jav]               target.putAt( $FIELD, null );
[$jav]             }

#elseif( $javaType.startsWith("ome") )
[$jav]             target.putAt($FIELD, ($javaType) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("IObject") )
[$jav]             target.set${PropertyName}( (ome.model.IObject) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("long"))
 ----------------> ERROR
#else
[$jav]             target.set${PropertyName}( this.get${PropertyName}() );
#end
#end##FOREACH

[$jav]           }
[$jav]           return target;
[$jav]         }

MISCELLANEOUS METHODS:

[$jav]     /**
[$jav]      * Casts (without warning) the given list to a list of
[$jav]      * the current type. 
[$jav]      * @throws ClassCastException
[$jav]      */
[$jav]     @SuppressWarnings("unchecked") public static List<${PojoI}> cast(List list) { return list; }


END DECLARATION BLOCK:

[$jav] }
[$hdr]  };
[$hdr]  typedef IceUtil::Handle<${PojoI}> ${PojoI}Ptr;
[$hdr]

[$cpp]}}
[$hdr]}}
[$hdr] #endif // ${POJOI}_H
[$ice]     };
[$ice]   };
[$ice] };
[$ice] #endif // ${POJO}_ICE
[$pyc] _omero_model.${PojoI} = ${PojoI}
#stop

