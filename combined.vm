#*
 *   $Id$
 *
 *   Copyright 2007,2008 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 *#

Note: lines not prefixed with [...] will be omitted in the final product.
The other prefixes are used by blitz/build.xml to determine how this file
wil be split. This is done because the individual velocity if/elseif's
and sets are nearly identical.

Here we turn off all prefixes except for ice.  Since <>I files are
concrete implementations, they should only be generated for concrete
classes. Capitalized versions will be turned on even for abstract classes.

#set( $ALL = "all" )
#set( $JAV = "jav" )
#set( $CPP = "cpp" )
#set( $HDR = "hdr" )
#set( $PYC = "pyc" )
#set( $ice = "ice" )
#set( $all = "all" )
#set( $jav = "jav" )
#set( $cpp = "cpp" )
#set( $hdr = "hdr" )
#set( $pyc = "pyc" )
#if($type.abstract)
#set( $all = "abs" )
#set( $jav = "abs" )
#set( $cpp = "abs" )
#set( $hdr = "abs" )
#set( $pyc = "abs" )
#end

Copyright notice added to all files:
[$PYC] """
[$ALL] /*
[$ALL]  *   Generated by blitz/templates/resouces/combined.vm
[$hdr]  *   See ../../README.h for information on these types.
[$ice]  *   See ../../README.ice for information on these types.
[$ALL]  *
[$ALL]  *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
[$ALL]  *   Use is subject to license terms supplied in LICENSE.txt
[$ALL]  *
[$ALL]  */
[$PYC] """

CONSTANTS -- Don't change for whole file
#set($Pojo  = "${type.shortname}")
#set($PojoI = "${Pojo}I")
#set($POJO  = "${Pojo.toUpperCase()}")
#set($POJOI = "${PojoI.toUpperCase()}")
#set($JAV_CURRENT = "Ice.Current current" )
#set($PYC_CURRENT = "current = Ice.Current()" )
#set($CPP_CURRENT = "const Ice::Current& current" )
#set($HDR_CURRENT = "${CPP_CURRENT} = Ice::Current()")


DECLARATION BLOCK:
=====================================================================================================

[$ice] #ifndef ${POJO}_ICE
[$ice] #define ${POJO}_ICE
[$hdr] #ifndef ${POJOI}_H
[$hdr] #define ${POJOI}_H

[$ice] \#include <omero/fwd.ice>
[$ice] \#include <omero/IObject.ice>
[$ice] \#include <omero/RTypes.ice>
[$ice] \#include <omero/System.ice>
#if( $type.superclass )
#set( $parent = $type.superclass.replaceFirst(".*ome.model..+?[.]","") )
[$ice] \#include <omero/model/${parent}.ice>
#set( $include = '\#include' )
#set( $importModify = '.replaceAll("^","[ice]").replaceAll(".*java.*","").replaceAll("import.*[.](.*?);","$include <omero/model/$1.ice>") ' )
\$secondpassclassimports\$importModify
#end
[$hdr] \#include <omero/ClientErrors.h>
[$hdr] \#include <omero/IObject.h>
[$hdr] \#include <omero/model/DetailsI.h>
[$hdr] \#include <omero/model/${Pojo}.h>
[$hdr] \#include <omero/ModelI.h>
[$hdr] \#include <omero/templates.h>

[$ice] module omero {
[$ice]   module model {

[$jav] package omero.model;
[$jav] import  java.util.*;
[$jav] import  ome.conditions.*;
[$jav] public class ${PojoI} extends ${Pojo}
[$jav]    implements ome.model.ModelBased {

Note how the whitespace for the python definitions is important.
[$pyc] import Ice
[$pyc] import omero_model_DetailsI
[$pyc] import omero_model_${Pojo}_ice
[$pyc] _omero = Ice.openModule("omero")
[$pyc] _omero_model = Ice.openModule("omero.model")
[$pyc] __name__ = "omero.model"

[$pyc] class ${PojoI}(_omero_model.$Pojo):
[$pyc]
[$hdr] namespace omero { 
[$hdr]   namespace model {
[$hdr]     class ${PojoI} : virtual public ${Pojo} { 

[$cpp] \#include <omero/model/${Pojo}I.h>
[$cpp] namespace omero { 
[$cpp]   namespace model {

STATIC FIELDS:

[$hdr]    public:
#foreach( $property in $type.propertyClosure )
[$jav]       public final static String ${property.nameUpper} = "${type.id}_${property.name}";
[$pyc]       ${property.nameUpper} =  "${type.id}_${property.name}"
[$hdr]       static const std::string ${property.nameUpper};
[$cpp]       const std::string ${PojoI}::${property.nameUpper} =  "${type.id}_${property.name}";
#end

[$hdr]     protected:

GENERATOR:

[$pyc]       class ${Pojo}I_generator:
[$pyc]           """
[$pyc]           This generator is used by the ObjectFactory to create
[$pyc]           new ${Pojo}I instances.
[$pyc]           """
[$pyc]           def __iter__(self):
[$pyc]               return self
[$pyc]           def next(self):
[$pyc]               return ${Pojo}I()
[$pyc]
[$pyc]       def generator(cls):
[$pyc]           return cls.${Pojo}I_generator()
[$pyc]       generator = classmethod(generator)
[$pyc]

INTERNAL METHODS:

[$hdr]       void errorIfUnloaded();
[$cpp]       void ${PojoI}::errorIfUnloaded()
[$cpp]       {
[$cpp]         if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
[$cpp]       }
[$jav]       protected void errorIfUnloaded() throws omero.UnloadedEntityException
[$jav]       {
[$jav]         if ( ! loaded ) throw new omero.UnloadedEntityException("Object unloaded:"+this);
[$jav]       }
[$pyc]       def errorIfUnloaded(self):
[$pyc]           if not self._loaded:
[$pyc]               raise _omero.UnloadedEntityException("Object unloaded:"+str(self))
[$pyc]
[$hdr]       void throwNullCollectionException(std::string propertyName);
[$cpp]       void ${PojoI}::throwNullCollectionException(std::string propertyName)
[$cpp]       {
[$cpp]         std::string s = "Error updating collection:" + propertyName +"\n"+
[$cpp]         "Collection is currently null. This can be seen\n"+
[$cpp]         "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$cpp]         "that this collection was unloaded. Please refresh this object\n"+
[$cpp]         "in order to update this collection.\n";
[$cpp]         throw omero::UnloadedCollectionException(
[$cpp]            __FILE__,__LINE__,s.c_str());
[$cpp]       }
[$jav]       protected void throwNullCollectionException(String propertyName) throws omero.UnloadedCollectionException
[$jav]       {
[$jav]          throw new omero.UnloadedCollectionException(
[$jav]            "Error updating collection:" + propertyName +"\n"+
[$jav]            "Collection is currently null. This can be seen\n"+
[$jav]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$jav]            "that this collection was unloaded. Please refresh this object\n"+
[$jav]            "in order to update this collection.\n"
[$jav]            );
[$jav]       }
[$pyc]       def throwNullCollectionException(self,propertyName):
[$pyc]           raise _omero.UnloadedEntityException(""+
[$pyc]           "Error updating collection:" + propertyName +"\n"+
[$pyc]           "Collection is currently null. This can be seen\n" +
[$pyc]           "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$pyc]           "that this collection was unloaded. Please refresh this object\n"+
[$pyc]           "in order to update this collection.\n")
[$pyc]

DESTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       virtual ~${PojoI}();
[$cpp]     ${PojoI}::~${PojoI}() {}

[$hdr]     public:


DEFAULT CONSTRUCTOR BLOCK:
=====================================================================================================


[$hdr]       ${PojoI}();
[$jav]       public ${PojoI}() {
[$cpp]       ${PojoI}::${PojoI}() : ${Pojo}() {
[$cpp]           loaded = true;
[$cpp]           toggleCollectionsLoaded(true);
[$cpp]           details = new omero::model::DetailsI();
[$jav]           loaded = true;
[$jav]           toggleCollectionsLoaded(true);
[$jav]           details = new omero.model.DetailsI();
[$jav]       }
[$cpp]       }

Python combines the two constructors. See below for a comparison.
[$pyc]       def __init__(self,id = None, loaded = True):
[$pyc]           super(${Pojo}I, self).__init__()
[$pyc]           self.id = id
[$pyc]           self._loaded = loaded
[$pyc]           if self._loaded:
[$pyc]              self._details = _omero_model.DetailsI()
[$pyc]              self._toggleCollectionsLoaded(True)
[$pyc]

TOGGLE AND CREATE COLLECTIONS:
=====================================================================================================

[$Ice]       void unloadCollections();
[$jav]       public void unloadCollections($JAV_CURRENT) {
[$jav]           toggleCollectionsLoaded(false);
[$jav]       }

[$hdr]       virtual void unloadCollections($HDR_CURRENT);
[$cpp]       void ${PojoI}::unloadCollections($CPP_CURRENT) {
[$cpp]           toggleCollectionsLoaded(false);
[$cpp]       }
[$pyc]       def unloadCollections(self, $PYC_CURRENT):
[$pyc]           self._toggleCollectionsLoaded(false)

[$jav]       protected void toggleCollectionsLoaded(boolean load) {
[$hdr]    protected:
[$hdr]       virtual void toggleCollectionsLoaded(bool load);
[$cpp]    void ${PojoI}::toggleCollectionsLoaded(bool load) {
[$pyc]       def _toggleCollectionsLoaded(self,load):
#foreach( $property in $type.propertyClosure )
#set(     $PropertyName = $property.nameCapped )
#set(     $javaType = $property.type)
#set(     $seqName = "${Pojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set($genericType = $property.type)
#set($genericType = $genericType.replaceFirst("ome.model..+?[.]","omero::model::"))
#set($genericTypeC = "${genericType.replaceAll('[.]','::')}")

Here we don't have to keep up with the type (set/list)
since all collections are lists in ice.

#if(      $fulltype.contains("byte[]"))
[$ice]     sequence<byte> ${seqName};

#elseif(  $property.one2Many )

[$ice]     ["java:type:java.util.ArrayList"] sequence<$genericTypeC> ${seqName};
#if( $property.isLink )
[$ice]     ["java:type:java.util.ArrayList"] sequence<${property.shortTarget}> ${Pojo}Linked${property.shortTarget}Seq;
#end

[$jav]           if (load) {
[$jav]               ${property.name}Seq = new ArrayList();
[$jav]               ${property.name}Loaded = true;
[$jav]           } else {
[$jav]               ${property.name}Seq = null;
[$jav]               ${property.name}Loaded = false;
[$jav]           }
[$cpp]           if (load) {
[$cpp]               ${property.name}Seq = ${seqName}();
[$cpp]               ${property.name}Loaded = true;
[$cpp]           } else {
[$cpp]               ${property.name}Seq = (${seqName})0;
[$cpp]               ${property.name}Loaded = false;
[$cpp]           }
[$pyc]           if load:
[$pyc]               self._${property.name}Seq = []
[$pyc]               self._${property.name}Loaded = True;
[$pyc]           else:
[$pyc]               self._${property.name}Seq = []
[$pyc]               self._${property.name}Loaded = False;
[$pyc]
#end##byte[]
#end##FOREACH
[$jav]    }
[$cpp]    }
##               In case there are no collections
[$pyc]           pass
[$pyc]

ICE CLASS BLOCK:
=====================================================================================================

Calculate inheritance. This is done here because sequences must first be defined.

#set( $base = "omero::model::IObject" )
#set( $extendsDeclaration = $base )
#if(  $type.superclass )
#set( $extendsDeclaration = $type.superclass.replaceFirst("ome.model..+?[.]","omero::model::" ) )
#end

[$ice]     ["protected"] class ${type.shortname}
[$ice]     extends $extendsDeclaration
[$ice]     {

UNLOADED CONSTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       ${PojoI}(omero::RLongPtr idPtr, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(omero::RLongPtr idPtr, bool isLoaded) : ${Pojo}() {
[$cpp]      id = idPtr;
[$cpp]      loaded = isLoaded;
[$cpp]      if (loaded) details = new omero::model::DetailsI(); 
[$cpp]      toggleCollectionsLoaded(isLoaded);
[$cpp]    }
[$jav]    public ${PojoI}(long id, boolean loaded) {
[$jav]      this.id = new omero.RLong(id);
[$jav]      this.loaded = loaded; 
[$jav]      if (loaded) details = new omero.model.DetailsI();
[$jav]    }
See single Python constructor above.

LOADNESS BLOCK:
=====================================================================================================

[$jav]       public void unload($JAV_CURRENT) {
[$hdr]       virtual void unload($HDR_CURRENT);
[$cpp]       void ${PojoI}::unload($CPP_CURRENT) {
[$pyc]       def unload(self, $PYC_CURRENT):
[$pyc]           self._loaded = False
[$jav]           loaded = false;
[$cpp]           loaded = false;
#foreach($property in $type.propertyClosure)
#if(!$clazz.identifierProperty.equals($property))
#set( $PropertyName = $property.nameCapped )
[$jav]           unload${PropertyName}( );
[$cpp]           unload${PropertyName}( );
[$pyc]           self.unload${PropertyName}( )
#end
#end##FOREACH
[$pyc]
[$jav]    }
[$cpp]    }

[$jav]       public boolean isLoaded($JAV_CURRENT) {
[$hdr]       virtual bool isLoaded($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isLoaded($CPP_CURRENT) {
[$pyc]       def isLoaded(self, $PYC_CURRENT):
[$pyc]           return self._loaded
[$jav]           return loaded;
[$cpp]           return loaded;
[$jav]    }
[$cpp]    }

INTERFACE METHODS:
=====================================================================================================
Since all the language bindings don't support the concept of interfaces,
the IObject abstract base class declares several methods that all concrete
implementations must define.

[$jav]       public boolean isGlobal($JAV_CURRENT) {
[$jav]           return #if($type.global) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isGlobal($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isGlobal($CPP_CURRENT) {
[$cpp]           return #if($type.global) true #else false #end;
[$cpp]       }
[$pyc]       def isGlobal(self, $PYC_CURRENT):
[$pyc]           return #if($type.global) True #else False #end;

[$jav]       public boolean isMutable($JAV_CURRENT) {
[$jav]           return #if($type.immutable) false #else true #end;
[$jav]       }
[$hdr]       virtual bool isMutable($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isMutable($CPP_CURRENT) {
[$cpp]           return #if($type.immutable) false #else true #end;
[$cpp]       }
[$pyc]       def isMutable(self, $PYC_CURRENT):
[$pyc]           return #if($type.immutable) False #else True #end;

[$jav]       public boolean isAnnotated($JAV_CURRENT) {
[$jav]           return #if($type.annotated) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isAnnotated($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isAnnotated($CPP_CURRENT) {
[$cpp]           return #if($type.annotated) true #else false #end;
[$cpp]       }
[$pyc]       def isAnnotated(self, $PYC_CURRENT):
[$pyc]           return #if($type.annotated) True #else False #end;

[$jav]       public boolean isLink($JAV_CURRENT) {
[$jav]           return #if($type.isLink) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isLink($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isLink($CPP_CURRENT) {
[$cpp]           return #if($type.isLink) true #else false #end;
[$cpp]       }
[$pyc]       def isLink(self, $PYC_CURRENT):
[$pyc]           return #if($type.isLink) True #else False #end;


SPECIAL METHODS:
=====================================================================================================
Id and Details acccesors defined like accessors below. This is necessary here
since id and details (like the loadedness methods above) are defined in IObject.ice
and cannot appear in every concrete <>I class. Therefore, we define them here
and protect later FOREACH blocks with "if (name == 'id' || name == 'details') skip;"

[$jav]       public omero.RLong getId($JAV_CURRENT) {
[$jav]           return id;
[$jav]       }
[$jav]
[$jav]       public void setId( omero.RLong id, $JAV_CURRENT ) {
[$jav]           this.id = id;
[$jav]       }
[$jav]
[$jav]       public omero.model.Details getDetails($JAV_CURRENT) {
[$jav]           return this.details;
[$jav]       }
[$jav]
[$jav]       public void unloadDetails($JAV_CURRENT) {
[$jav]           this.details = null;
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by copyObject below to take an ome.model instance and
[$jav]        * set the values on this instance.
[$jav]        */
[$jav]       private void copyDetails(ome.model.IObject source, omero.util.IceMapper mapper) {
[$jav]           this.details = (omero.model.Details) mapper.findTarget( source.getDetails() );
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by fillObject below to take this instance and
[$jav]        * set the values on the target ome.model. instance.
[$jav]        */
[$jav]       private void fillDetails(ome.model.IObject target, omero.util.IceMapper mapper) {
[$jav]           ome.model.internal.Details details = (ome.model.internal.Details) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() );
[$jav]           if (details != null) {
[$jav]               target.getDetails().copy( details );
[$jav]           }
[$jav]       }
[$jav]

[$hdr]       virtual omero::model::DetailsPtr getDetails($HDR_CURRENT);
[$hdr]       virtual void unloadDetails($HD_CURRENT);
[$hdr]       virtual omero::RLongPtr getId($HDR_CURRENT);
[$hdr]       virtual void setId( const omero::RLongPtr& id, $HDR_CURRENT );

[$cpp]       omero::model::DetailsPtr ${PojoI}::getDetails($CPP_CURRENT) {
[$cpp]           return details;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::unloadDetails($CPP_CURRENT) {
[$cpp]           details = new omero::model::Details();
[$cpp]       }
[$cpp]
[$cpp]       omero::RLongPtr ${PojoI}::getId($CPP_CURRENT) {
[$cpp]           return id;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setId(const omero::RLongPtr& _id, $CPP_CURRENT) {
[$cpp]           id = _id;
[$cpp]       }

[$pyc]       def getDetails(self, $PYC_CURRENT):
[$pyc]           return self._details
[$pyc]
[$pyc]       def unloadDetails(self, $PYC_CURRENT):
[$pyc]           self._details = None
[$pyc]
[$pyc]       def getId(self, $PYC_CURRENT):
[$pyc]           return self._id
[$pyc]
[$pyc]       def setId(self, _id, $PYC_CURRENT):
[$pyc]           self._id = _id
[$pyc]
Doing unloadedPython as a method because of the multi-line restriction. See below.
[$pyc]       def checkUnloadedProperty(self, value, loadedField):
[$pyc]           if value == None:
[$pyc]               self.__dict__[loadedField] = False
[$pyc]           else:
[$pyc]               self.__dict__[loadedField] = True
[$pyc]


MUTABLE
=====================================================================================================
The "version" property is not a part of the model but is calculated from mutability.

#if( ! $type.immutable )
#if( ! $type.superclass )
[$ice]       omero::RInt version;
[$ice]       omero::RInt getVersion();
[$ice]       void setVersion(omero::RInt theVersion);
#end ! superclass

[$jav]       public omero.RInt getVersion($JAV_CURRENT) {
[$jav]           return this.version;
[$jav]       }
[$jav]
[$jav]       public void setVersion( omero.RInt version, $JAV_CURRENT ) {
[$jav]           this.version = version;
[$jav]       }
[$jav]

[$hdr]       virtual omero::RIntPtr getVersion($HDR_CURRENT);
[$hdr]       virtual void setVersion( const omero::RIntPtr& version, $HDR_CURRENT );

[$cpp]       omero::RIntPtr ${PojoI}::getVersion($CPP_CURRENT) {
[$cpp]           return version;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setVersion(const omero::RIntPtr& _version, $CPP_CURRENT) {
[$cpp]           version = _version;
[$cpp]       }

[$pyc]       def getVersion(self, $PYC_CURRENT):
[$pyc]           return self._version
[$pyc]
[$pyc]       def setVersion(self, version, $PYC_CURRENT):
[$pyc]           self._version = version
[$pyc]
#end### ! immutable 


###########################################################################
#foreach($property in $type.propertyClosure)#############
###########################################################################

This is the main loop through all of the properties. Where possible, methods
should be created here which simplify the other sections of code generation.

FIELD & ACCESSORS BLOCK:
=====================================================================================================

These mappings are from HibernateTypes-->IceTypes

Ice properties should only be defined once (not in every subclass, obviously).
However, because of Ice's inheritance structure, we are here using
propertyClosure which gives us superclass fields. These must be filtered
in the [Ice] sections below, but not for all others.

#if( $property.name.equals("id") || $property.name.equals("details"))## SPECIAL EXCEPTIONS

Skip. These are defined in omero.IObject.ice

#else## All other properties are treated normally

[$hdr]
[$hdr]       //
[$hdr]       //  ${Pojo}.${property.name}
[$hdr]       //

#set( $definedIn = "nothere" )
#foreach( $p2 in $type.classProperties )
##
#if( $p2.name.equals($property.name) )
#set( $definedIn = "here" )
#end
#end
#set($Ice = "ice" )
#if( $definedIn.startsWith("not") )
#set($Ice = "NOT" )
#end


Properties used throughout the accessor generation

## TODO: UNIFY THESE
#set( $PropertyName = $property.nameCapped)
#set( $STATICFIELDNAME = "${type.id}.${PropertyName.toUpperCase()}" )
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $iceType = "ERROR" )## Must be reset on each iteration
#set( $cppType = "ERROR" )##  ditto
#set( $open = " " )
#set( $close= " " )
#set( $prefix=" " )
#set( $suffix=" " )
#set( $unloadedJava=" " )
#set( $unloadedCpp=" " )
#set( $unloadedPython="pass" )
#set( $copyMethod = "ERROR" )
#set( $fieldName = "${property.name}") ## Changed for sequences to nameSeq
#set( $getter = "this.${fieldName}" )
#set( $setter = "${fieldName}" )

 TODO: Currently the findTarget methods have separate names.
 Instead there should be a cast to guarantee that the right
 method is invoked.

## Here we are taking the pojo name from the ST of the property, rather than the
## current ST in order to handle subclasses wrt. links. This may need to be done for
## every property right after the foreach.
#set( $truePojo = "${property.getST().shortname}" )
#set( $seqName = "${truePojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set( $propLoaded = "${property.Name}Loaded" )

## TODO use empty List or null?

#if( $property.one2Many )##JAVA_TYPE ----------------------------------------------
## #684 Mapping all sets to lists.
#set( $javaType = "java.util.List" )
#set( $getter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( this.$property.name ) " )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( $property.name )" )
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $iceType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} != ($cppType) 0) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )
#set( $unloadedPython = "self.checkUnloadedProperty(_${property.name},'${propLoaded}')" )
#set( $fieldName = "${property.name}Seq")
#set( $getter = "this.${fieldName}" )
## See ticket:684
## If this is the case, we can't use the accessor and have to use a generated method
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findCollection( (Collection) source.retrieve(${type.id}.${PropertyName.toUpperCase()}));" );

[$Ice]       $seqName ${fieldName};
[$Ice]       bool ${property.name}Loaded;
#if( $property.isLink )
[$Ice]       omero::sys::CountMap ${property.name}CountPerOwner;
#end

#elseif( $javaType.startsWith("ome"))## Had to be moved before "*Map" rule ---------
#set( $javaType = "omero.model.${shortType}" )
#set( $getter = "(omero.model.${shortType}) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::${shortType}" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findTarget(source.get${PropertyName}());" );
[$Ice]       omero::model::${shortType} ${property.name};

#elseif( $javaType.startsWith("IObject"))## Special case of the previous------------
#set( $javaType = "omero.model.IObject")
#set( $getter = "(omero.model.IObject) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::IObject")
#set( $cppType = "${iceType}Ptr")
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findTarget(source.get${PropertyName}());" );
[$Ice]       omero::model::IObject ${property.name};

#elseif( $javaType.startsWith("java.lang.Boolean"))## -------------------------------
#set( $javaType = "omero.RBool");
#set( $iceType   = "omero::RBool" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}());" );
[$Ice]       omero::RBool ${property.name};

#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $javaType = "omero.RInt");
#set( $iceType   = "omero::RInt" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}());" );
[$Ice]       omero::RInt ${property.name};

#elseif( $javaType.startsWith("java.lang.Long"))
#set( $javaType = "omero.RLong");
#set( $iceType   = "omero::RLong" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}());" );
[$Ice]       omero::RLong ${property.name};

#elseif( $javaType.startsWith("java.lang.Double"))
#set( $javaType = "omero.RDouble");
#set( $iceType   = "omero::RDouble" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}());" );
[$Ice]       omero::RDouble ${property.name};

#elseif( $javaType.startsWith("java.lang.Float"))
#set( $javaType = "omero.RFloat");
#set( $iceType   = "omero::RFloat" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}());" );
[$Ice]       omero::RFloat ${property.name};

#elseif( $javaType.equals("byte[]"))
#set( $javaType = "byte[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::ByteSeq")
#set( $cppType = "Ice::ByteSeq")
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}();")
[$Ice]       Ice::ByteSeq ${property.name};

#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "Long" )
#set( $getter   = "new Long(this.$property.name)" )
#set( $setter = "(${property.name} == null) ? 0 : this.$property.name == ${property.name}.longValue()")
#set( $iceType = "long" )
#set( $cppType = "long" )
#set( $copyMethod = "ome.util.Utils.internalForm(source)" )
[$Ice]       long ${property.name};

#elseif( $javaType.startsWith("java.util.Map") )
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findMap(source.get${PropertyName}());" );
[$Ice]       dictionary ${property.name};

#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $javaType = "omero.RTime");
#set( $iceType = "omero::RTime" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}().getTime() );" );
[$Ice]       omero::RTime ${property.name};

#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $javaType = "omero.RString");
#set( $iceType = "omero::RString" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : new ${javaType}(source.get${PropertyName}() );" );
[$Ice]       omero::RString ${property.name};

#else
[$all]...ERROR...$javaType unknown.

#end##JAVA_TYPE

Here we only add the getters and setters to Ice if this is not a collection,
since slice has no concept of visibility. Instead, the special collection
methods below will be used for access.

#if( ! $property.one2Many )
[$Ice]       $iceType get${PropertyName}();
[$Ice]       void set${PropertyName}($iceType the${PropertyName});
#end

ASSOCIATION TYPES BLOCK:
=====================================================================================================

#set( $hasSet  = false )
#set( $hasLink = false )
#if( $property.one2Many )
#set( $hasSet  = $property.one2Many)
#end
#if( $property.class.name.equals("ome.dsl.ChildLink") || $property.class.name.equals("ome.dsl.ParentLink"))
#set( $hasLink = true )
#end

#set( $access = "protected" )
#set( $unloadIfIsSet = "${property.Name}Loaded = false;")
#if( !$hasSet && !$hasLink)
#set( $access = "public" )
#set( $unloadIfIsSet = "");
#end

Unload
------

[$jav]       public void unload${PropertyName}() {
[$jav]           ${unloadIfIsSet}
[$jav]           ${fieldName} = null;
[$jav]       }
[$hdr]       virtual void unload${PropertyName}();
[$cpp]       void ${Pojo}I::unload${PropertyName}() {
[$cpp]           ${unloadIfIsSet}
[$cpp]           ${fieldName} = ($cppType) 0;
[$cpp]       }
[$pyc]       def unload${PropertyName}(self):
[$pyc]           self._${property.name}Loaded = False
[$pyc]           self._${fieldName} = None;
[$pyc]
Original accessors: will have their visibility reduced if
the special set methods are added.

[$jav]       $access $javaType get${property.nameCapped}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return $getter;
[$jav]       }
[$jav]
[$jav]       $access void set${PropertyName}($javaType $property.name, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           this.$fieldName = $setter;
[$jav]           $unloadedJava
[$jav]       }
[$jav]
[$jav]       private void copy${PropertyName}($type.id source, omero.util.IceMapper mapper) {
[$jav]           $copyMethod
#if ($property.one2Many && $property.isLink)
[$jav]           this.${property.name}CountPerOwner = source.get${property.nameCapped}CountPerOwner();
#end
[$jav]       }
[$jav]
[$jav]       private void fill${PropertyName}($type.id target, omero.util.IceMapper mapper) {
#if( $type.id.equals("ome.model.internal.Permissions") )
[$jav]             ome.model.internal.Permissions p = ome.util.Utils.toPermissions((Long)this.getPerm1());
[$jav]             target.revokeAll(ome.model.internal.Permissions.EMPTY); // AND
[$jav]             target.grantAll(p); // OR

#elseif( $property.one2Many )
## If this is the case, we can't use the accessor and have to use a generated method

[$jav]             if (this.${propLoaded}) {

ticket:684 This is necessary to map back and forth from sets.
#set( $fieldType = $property.fieldType.replaceAll("[<].*[>]",""))
[$jav]               target.putAt( $STATICFIELDNAME, mapper.reverse( this.${fieldName}, ${fieldType}.class ));
[$jav]             } else {
[$jav]               target.putAt( $STATICFIELDNAME, null );
[$jav]             }

#elseif( $javaType.startsWith("omero.R") )
[$jav]             try {
[$jav]                 target.set${PropertyName}( (${property.type}) mapper.fromRType( this.get${PropertyName}() ));
[$jav]             } catch (omero.ApiUsageException aue) {
[$jav]                 throw new omero.ClientError(aue.message);
[$jav]             }
#elseif( $javaType.startsWith("ome") )
[$jav]             target.putAt($STATICFIELDNAME, mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("IObject") )
[$jav]             target.set${PropertyName}( mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("long"))
 ----------------> ERROR
#else
[$jav]             target.set${PropertyName}( this.get${PropertyName}() );
#end
[$jav]       }
[$jav]


#if($access == "protected" )
[$hdr]     protected:
#end
[$hdr]       virtual $cppType get${property.nameCapped}($HDR_CURRENT);
[$hdr]       virtual void set${PropertyName}(const $cppType& _$property.name, $HDR_CURRENT);
#if($access == "protected" )
[$hdr]     public:
#end

[$cpp]       $cppType ${PojoI}::get${property.nameCapped}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${open}${fieldName}${close};
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::set${PropertyName}(const ${cppType}& _$property.name, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           $fieldName = $!{prefix}_${property.name}$!{suffix};
[$cpp]           $unloadedCpp
[$cpp]       }

#set($pyaccess = "")
#if($property.one2Many)
#set($pyaccess = "_")
#end

It's unclear if these methods are useful at all, but for the moment lowering their
"visibility" to make __getattr__ logic work properly.

[$pyc]       def ${pyaccess}get${property.nameCapped}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self._${fieldName}
[$pyc]
[$pyc]       def ${pyaccess}set${PropertyName}(self, _${property.name}, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self._${fieldName} = _${property.name}
[$pyc]           $unloadedPython
[$pyc]


One-to-many extras:
======================================================================================
##  (copied from dsl/resources/ome/dsl/object.vm):
##  A one-to-many property represents a set that is contained by this entity.
##  These methods represent our handling of Hibernate's "inverse" sets
##  which do not act as expected with regards to getters & setters.
##
##  To prevent users from making mistakes like not properly setting both 
##  sides of a relationship, these fields are hidden, and only accessible via
##  the following methods. Methods fall into several categories: 
##    (A) general   
##    (B) list-only
##    (C) link-based
##
##  (A) General one-to-many code
##  ----------------------------
##

#if( $hasSet || $hasLink )

isXLoaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The isXLoaded checks are not present in the ome.model classses
since we can use the nullness of the Java reference to check for
that. In Ice, we'd have to use an RCollection to use nullness,
which would take away our type safety. Instead, we add a boolean
field for every sequence. NOTE: These methods may not be needed
and instead sizeOf would suffice.

[$jav]       public boolean is${PropertyName}Loaded() {
[$jav]           return ${propLoaded};
[$jav]       }
[$hdr]       virtual bool is${PropertyName}Loaded();
[$cpp]       bool ${PojoI}::is${PropertyName}Loaded( ) {
[$cpp]           return ${propLoaded};
[$cpp]       }
[$pyc]       def is${PropertyName}Loaded(self):
[$pyc]           return self._${propLoaded}
[$pyc]

sizeOf ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       int sizeOf${PropertyName}();
[$jav]       public int sizeOf${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) return -1;
[$jav]           return ${fieldName}.size();
[$jav]       }
[$hdr]       virtual Ice::Int sizeOf${PropertyName}($HDR_CURRENT);
[$cpp]       Ice::Int ${PojoI}::sizeOf${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) return -1;
[$cpp]           return ${fieldName}.size();
[$cpp]       }
[$pyc]       def sizeOf${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: return -1
[$pyc]           return len(self._${fieldName})
[$pyc]

Copy ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       $iceType copy${PropertyName}();
[$jav]       public $javaType copy${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$javaType> result = new ArrayList(${fieldName});
[$jav]           return result;
[$jav]       }
[$pyc]       def copy${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return list(self._${fieldName})
[$pyc]
             Here we don't have a vector<$cppType> since the type is typedef'd
[$hdr]       virtual $cppType copy${PropertyName}($HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::copy${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType result(${fieldName}.size());
[$cpp]           std::copy(${fieldName}.begin(), ${fieldName}.end(), result.begin());
[$cpp]           return result;
[$cpp]       }

Iterators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Iterators are language-specific since there's no slice concept
for them. Therefore, to use these, developers must down-cast.

[$Ice]       // See language-specific iterator methods
[$jav]       public Iterator iterate${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.iterator();
[$jav]       }
[$hdr]       virtual $cppType::iterator begin${PropertyName}();
[$hdr]       virtual $cppType::iterator end${PropertyName}();
[$cpp]       $cppType::iterator ${PojoI}::begin${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.begin();
[$cpp]       }
[$cpp]       $cppType::iterator ${PojoI}::end${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.end();
[$cpp]       }
[$pyc]       def iterate${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return iter(self._${fieldName})
[$pyc]

#end


------------------------------------------------------------
Because of the ice inheritance hierarchy, we must use direct
field access on several methods below.
------------------------------------------------------------

Set modifications:

#if( $hasSet )
#set( $inverse = $property.inverse )
#set( $inverselength = $inverse.length() )
#set( $Inverse = "${inverse.substring(0,1).toUpperCase()}${inverse.substring(1,$inverselength)}" )

add single

[$Ice]       void add${property.shortType}(${property.shortType} target);
[$jav]       public void add${property.shortType}(${property.shortType} target, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( target );
[$jav]           target.set$Inverse( this );
[$jav]       }
[$pyc]       def add${property.shortType}(self, target, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.append( target );
[$pyc]           target.set$Inverse( self )
[$pyc]
[$hdr]       virtual void add${property.shortType}(const ${property.shortType}Ptr& target, $HDR_CURRENT);
[$cpp]       void ${PojoI}::add${property.shortType}(const ${property.shortType}Ptr& target, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( target );
[$cpp]           target->set$Inverse(this);
[$cpp]       }

add set

[$jav]       public void add${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.addAll( targets );
[$jav]           for( ${property.shortType} target : targets) {
[$jav]               target.set$Inverse( this );
[$jav]           }
[$jav]       }
[$pyc]       def add${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if  not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.extend( targets )
[$pyc]           for target in targets:
[$pyc]               target.set$Inverse( self )
[$pyc]
[$hdr]       virtual void add${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::add${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator loc = ${fieldName}.end();
[$cpp]           $cppType::iterator beg = targets.begin(); 
[$cpp]           $cppType::iterator end = targets.end(); 
[$cpp]           ${fieldName}.insert(loc,beg,end);
[$cpp]           for ($cppType::iterator it = targets.begin(); it != targets.end(); ++it) {
[$cpp]               ${property.shortType}Ptr target = *it;
[$cpp]               target->set$Inverse( this );
[$cpp]           }
[$cpp]       }

remove single

[$Ice]       void remove${property.shortType}(${property.shortType} theTarget);
[$jav]       public void remove${property.shortType}(${property.shortType} target, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( target );
[$jav]           target.set$Inverse( null );
[$jav]       }
[$pyc]       def remove${property.shortType}(self, target, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.remove( target )
[$pyc]           target.set$Inverse( None )
[$pyc]
[$hdr]       virtual void remove${property.shortType}(const ${property.shortType}Ptr& target, $HDR_CURRENT);
[$cpp]       void ${PojoI}::remove${property.shortType}(const ${property.shortType}Ptr& target, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               omero::ContainsPointer<${property.shortType}Ptr>(target));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]           target->set$Inverse( (${PojoI}Ptr)0 );
[$cpp]       }

remove multiple

[$jav]       public void remove${property.shortType}Set(Collection<${property.shortType}> targets) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : targets) {
[$jav]               elt.set$Inverse( null );
[$jav]               ${fieldName}.remove( elt );
[$jav]           }
[$jav]       }
[$pyc]       def remove${property.shortType}Set(self, targets):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in targets:
[$pyc]               elt.set$Inverse( None )
[$pyc]               self._${fieldName}.remove( elt )
[$pyc]
[$hdr]       virtual void remove${property.shortType}Set($cppType targets);
[$cpp]       void ${PojoI}::remove${property.shortType}Set($cppType targets) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${cppType}::iterator end = ${fieldName}.end();
[$cpp]           ${cppType}::iterator removed = std::remove_if(
[$cpp]               ${fieldName}.begin(), end,
[$cpp]               omero::VectorContainsPointer<${property.shortType}Ptr>(targets));
[$cpp]           ${cppType}::iterator beg(removed);
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->set$Inverse( (${PojoI}Ptr)0 );
[$cpp]           }
[$cpp]           ${fieldName}.erase(removed,end);
[$cpp]       }

clear

[$Ice]       void clear${PropertyName}();
[$jav]       public void clear${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : (Collection<${property.shortType}>)${fieldName}) {
[$jav]               elt.set$Inverse( null );
[$jav]           }
[$jav]           ${fieldName}.clear();
[$jav]       }
[$pyc]       def clear${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in self._${fieldName}:
[$pyc]               elt.set$Inverse( None )
[$pyc]           self._${fieldName} = list()
[$pyc]
[$hdr]       virtual void clear${PropertyName}($HDR_CURRENT);
[$cpp]       void ${PojoI}::clear${PropertyName}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator beg = ${fieldName}.begin();
[$cpp]           $cppType::iterator end = ${fieldName}.end();
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->set$Inverse( (${PojoI}Ptr)0 );
[$cpp]           }
[$cpp]           ${fieldName}.clear();
[$cpp]       }


(B) List Modifications
===============================================================

#if( ${property.ordered} )
[$Ice]       ${property.shortType} get${property.shortType}(int index);
[$Ice]       void set${property.shortType}(int index, ${property.shortType} theElement);
[$Ice]       ${property.shortType} getPrimary${property.shortType}();
[$Ice]       ${property.shortType} setPrimary${property.shortType}(${property.shortType} theElement);

[$jav]       public ${property.shortType} get${property.shortType}(int index, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.get(index);
[$jav]       }
[$jav]
[$jav]       public void set${property.shortType}(int index, ${property.shortType} element, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.set(index, element);
[$jav]       }
[$jav]
[$jav]       public ${property.shortType} getPrimary${property.shortType}($JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.get(0);
[$jav]       }
[$jav]
[$jav]       public ${property.shortType} setPrimary${property.shortType}(${property.shortType} element, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           int index = ${fieldName}.indexOf(element);
[$jav]           ${property.shortType} old = ${fieldName}.get(0);
[$jav]           ${fieldName}.set(index, old);
[$jav]           ${fieldName}.set(0, element);
[$jav]           return old;
[$jav]       }
[$jav]

#set( $CPPRETURNTYPE = "${property.shortType}Ptr")
[$hdr]       virtual $CPPRETURNTYPE get${property.shortType}(int index, $HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::get${property.shortType}(int index, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}[index];
[$cpp]       }
[$cpp]
[$hdr]       virtual void set${property.shortType}(int index, const ${property.shortType}Ptr& element, $HDR_CURRENT);
[$cpp]       void ${PojoI}::set${property.shortType}(int index, const ${property.shortType}Ptr& element, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}[index] = element;
[$cpp]       }
[$cpp]
[$hdr]       virtual $CPPRETURNTYPE getPrimary${property.shortType}($HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::getPrimary${property.shortType}($CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}[0];
[$cpp]       }
[$cpp]
[$hdr]       virtual $CPPRETURNTYPE setPrimary${property.shortType}(const ${property.shortType}Ptr& element, $HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::setPrimary${property.shortType}(const ${property.shortType}Ptr& element, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           int index = omero::indexOf(${fieldName}, element);
[$cpp]           $CPPRETURNTYPE old = ${fieldName}[0];
[$cpp]           ${fieldName}[index] = old;
[$cpp]           ${fieldName}[0] = element;
[$cpp]           return old;
[$cpp]       }
[$cpp]

[$pyc]       def get${property.shortType}(self, index, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return self._${fieldName}.get(index)
[$pyc]
[$pyc]       def set${property.shortType}(self, index, element, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self. _${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.set(index, element)
[$pyc]
[$pyc]       def getPrimary${property.shortType}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return self._${fieldName}[0]
[$pyc]
[$pyc]       def setPrimary${property.shortType}(self, element, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           index = self._${fieldName}.index(element)
[$pyc]           old = self._${fieldName}[0]
[$pyc]           self._${fieldName}[index] = old
[$pyc]           self._${fieldName}[0] = element
[$pyc]           return old
[$pyc]
#end##property.ordered


(C) Link Modifications
===============================================================

#if( $hasLink )

Here our "elements" from the above are the links which themselves
have linked elements.

#if($property.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "getParent()" )
#set( $other = "getChild()" )
#elseif($property.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "getChild()" )
#set( $other = "getParent()" )
#end
#set( $bidir = $property.bidirectional )
#set( $pyorder = $order.replaceAll("this","self"))

COUNTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#set( $GETCOUNTMETHOD = "get${property.nameCapped}CountPerOwner" )
#set( $GETCOUNTVALUE  = "${property.name}CountPerOwner" )
[$Ice]       omero::sys::CountMap $GETCOUNTMETHOD();
[$jav]       public java.util.Map<Long, Long> $GETCOUNTMETHOD($JAV_CURRENT) {
[$jav]           return this.$GETCOUNTVALUE;
[$jav]       }
[$jav]
[$hdr]       virtual omero::sys::CountMap $GETCOUNTMETHOD($HDR_CURRENT);
[$cpp]       omero::sys::CountMap ${PojoI}::$GETCOUNTMETHOD($CPP_CURRENT) {
[$cpp]           return $GETCOUNTVALUE;
[$cpp]       }
[$pyc]       def $GETCOUNTMETHOD(self, $PYC_CURRENT):
[$pyc]           return $GETCOUNTVALUE


ADD ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#set( $ADD2METHOD = "add${property.shortType}2")

[$Ice]       void link${property.shortTarget}(${property.shortTarget} addition);
[$jav]       public void link${property.shortTarget}(${property.shortTarget} addition, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${property.shortType}I link = new ${property.shortType}I();
[$jav]           link.link( ${order} );
[$jav]           $ADD2METHOD( link, true );
[$jav]       }
[$pyc]       def link${property.shortTarget}(self, addition, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           link = _omero_model.${property.shortType}I()
[$pyc]           link.link( ${pyorder} );
[$pyc]           self.$ADD2METHOD( link, True )
[$pyc]
[$hdr]       virtual void link${property.shortTarget}(const ${property.shortTarget}Ptr& addition, $HDR_CURRENT);
[$cpp]       void ${PojoI}::link${property.shortTarget}(const ${property.shortTarget}Ptr& addition, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${property.shortType}IPtr link = new ${property.shortType}I();
[$cpp]           link->link( ${order} );
[$cpp]           $ADD2METHOD( link, true );
[$cpp]       }

TODO: do we need to do link.parent = ...;

[$Ice]       void $ADD2METHOD(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void $ADD2METHOD(${property.shortType} link, boolean bothSides, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( link );
#if($bidir)
TODO: Should we check for nulls in other?
[$jav]           if (bothSides && link.${other}.isLoaded() ) {
[$jav]               ((${property.shortTarget})link.${other}).$ADD2METHOD( link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def $ADD2METHOD(self, link, bothSides):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.append( link )
#if($bidir) 
[$pyc]           if bothSides and link.${other}.isLoaded():
[$pyc]               link.${other}.$ADD2METHOD( link, False )
#end
[$pyc]
[$hdr]       virtual void $ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $HDR_CURRENT);
[$cpp]       void ${PojoI}::$ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( link );
#if($bidir)
[$cpp]           if (bothSides && link->${other}->isLoaded() ) {
[$cpp]               ${property.shortTarget}Ptr::dynamicCast(link->${other})->$ADD2METHOD( link, false );
[$cpp]           }
#end
[$cpp]       }  

FIND
================================

[$Ice]       $iceType find${property.shortType}(${property.shortTarget} removal);
[$jav]       public List<$property.shortType> find${property.shortType}(${property.shortTarget} removal, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List result = new ArrayList();
[$jav]           for( $property.shortType link : ${fieldName} ) {
[$jav]               if (link.${other} == removal) result.add(link);
[$jav]           }
[$jav]           return result;
[$jav]       }
[$pyc]       def find${property.shortType}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           result = list()
[$pyc]           for link in self._${fieldName}:
[$pyc]               if link.${other} == removal: result.append(link)
[$pyc]           return result
[$pyc]
[$hdr]       virtual $cppType find${property.shortType}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::find${property.shortType}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> result;
[$cpp]           $cppType::iterator beg = begin${PropertyName}();
[$cpp]           $cppType::iterator end = end${PropertyName}();
[$cpp]           while (beg != end) {
[$cpp]               if ((*beg)->${other} == removal) result.push_back( *beg );
[$cpp]               ++beg;
[$cpp]           }
[$cpp]           return result;
[$cpp]       }  

REMOVE
=======================================
#set( $REMOVE2METHOD = "remove${property.shortType}2")

#set( $removeLinkPredicate = "testRemove${property.shortTarget}From${PojoI}" )
[$cpp]
[$cpp]       struct $removeLinkPredicate {
[$cpp] 
[$cpp]         const ${property.shortType}Ptr t;
[$cpp]         const bool bothSides;
[$cpp]         ${removeLinkPredicate}(const ${property.shortType}Ptr n, const bool b) : t(n), bothSides(b) {}
[$cpp]         bool operator()(${property.shortType}Ptr const& o) {
[$cpp]            if (o == t) {
#if($bidir)
[$cpp]                if (bothSides && t->${other}->isLoaded()){
[$cpp]                    o->${other}->$REMOVE2METHOD(t,false);
[$cpp]                }
#end
[$cpp]                return true;
[$cpp]            }
[$cpp]            return false;
[$cpp]         }
[$cpp]       }; 
[$cpp]

[$Ice]       void unlink${property.shortTarget}(${property.shortTarget} removal);
[$jav]       public void unlink${property.shortTarget}(${property.shortTarget} removal, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$property.shortType> toRemove = find${property.shortType}(removal);
[$jav]           Iterator<$property.shortType> it = toRemove.iterator();
[$jav]           while( it.hasNext() ){
[$jav]               $REMOVE2METHOD( it.next(), true );
[$jav]           }
[$jav]       }

[$Ice]       void $REMOVE2METHOD(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void $REMOVE2METHOD(${property.shortType} link, boolean bothSides, $JAV_CURRENT  ) throws omero.UnloadedEntityException, omero.UnloadedCollectionException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( link );
#if($bidir)
[$jav]           if (bothSides && link.${other}.isLoaded()) {
[$jav]               ((${property.shortTarget})link.${other}).$REMOVE2METHOD(link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def unlink${property.shortTarget}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           toRemove = self.find${property.shortType}(removal)
[$pyc]           for next in toRemove:
[$pyc]               self.$REMOVE2METHOD( next, True )
[$pyc]
[$pyc]       def $REMOVE2METHOD(self, link, bothSides, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.remove( link )
#if($bidir)
[$pyc]           if bothSides and link.${other}.isLoaded():
[$pyc]               link.${other}.$REMOVE2METHOD(link, False)
#end
[$pyc]
[$hdr]       virtual void unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       void ${PojoI}::unlink${property.shortTarget}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> toRemove = find${property.shortType}(removal);
[$cpp]           $cppType::iterator beg = toRemove.begin();
[$cpp]           $cppType::iterator end = toRemove.end();
[$cpp]           while (beg != end) {
[$cpp]             $REMOVE2METHOD( *beg, true );
[$cpp]             ++beg;
[$cpp]           }
[$cpp]       }
[$hdr]       virtual void $REMOVE2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $HDR_CURRENT);
[$cpp]       void ${PojoI}::$REMOVE2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           // predicate may do reverse side
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               ${removeLinkPredicate}(link, bothSides));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]       } 

[TODO]      <some return> linked${property.shortTarget}List();
This will probably require a new sequence type.

[$Ice]       ${Pojo}Linked${property.shortTarget}Seq linked${property.shortTarget}List();
[$jav]    public List<${property.shortTarget}> linked${property.shortTarget}List($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]        errorIfUnloaded();
[$jav]        if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]        List<${property.shortTarget}> linked = new ArrayList<${property.shortTarget}>();
[$jav]        for (${property.shortType} link : ${fieldName}) {
[$jav]            linked.add( link.$other );
[$jav]        }
[$jav]        return linked;
[$jav]    }
Language-specific
[$jav]    public Iterator<${property.shortTarget}> linked${property.shortTarget}Iterator() throws omero.UnloadedEntityException {
[$jav]        errorIfUnloaded();
[$jav]        if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]        List<${property.shortTarget}> linked = new ArrayList<${property.shortTarget}>();
[$jav]        for (${property.shortType} link : ${fieldName}) {
[$jav]            linked.add( link.$other );
[$jav]        }
[$jav]        return linked.iterator();
[$jav]    }

[$pyc]       def find${property.shortType}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           result = list()
[$pyc]           for link in self._${fieldName}:
[$pyc]               if link.${other} == removal: result.append(link)
[$pyc]           return result
[$pyc]
[$hdr]       virtual $cppType find${property.shortType}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::find${property.shortType}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> result;
[$cpp]           $cppType::iterator beg = begin${PropertyName}();
[$cpp]           $cppType::iterator end = end${PropertyName}();
[$cpp]           while (beg != end) {
[$cpp]               if ((*beg)->${other} == removal) result.push_back( *beg );
[$cpp]               ++beg;
[$cpp]           }
[$cpp]           return result;
[$cpp]       }  

##[$hdr]    virtual std::vector<${property.shortTarget}Ptr>::iterator linked${property.shortTarget}Iterator();
##[$cpp]    std::vector<${property.shortTarget}Ptr>::iterator ${PojoI}::linked${property.shortTarget}Iterator() {
##[$cpp]        errorIfUnloaded();
##[$cpp]        std::vector<${property.shortTarget}Ptr>::iterator result;
##[$cpp]        return result;
##[$cpp]    }



#end##End hasLink
#end##End hasSet
#end##End SPECIAL EXCEPTIONS

##################################################################
#end##FOREACH#####################################################
##################################################################

CLASS-LEVEL EXTRA METHODS BLOCK:
=====================================================================================================

#if($type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = ${prop.shortType} )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = ${prop.shortType} )
#end
#end##FOREACH

[$Ice]       void link(${parent} theParent, ${child} theChild);
[$jav]       public void link(${parent} _parent, ${child} _child, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           setParent( _parent );
[$jav]           setChild( _child );
[$jav]       }
[$pyc]
[$pyc]       def link(self, _parent, _child, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.setParent( _parent )
[$pyc]           self.setChild( _child )
[$pyc]
[$hdr]       virtual void link(const ${parent}Ptr& parent, const ${child}Ptr& child, $HDR_CURRENT);
[$cpp]       void ${PojoI}::link(const ${parent}Ptr& _parent, const ${child}Ptr& _child, $CPP_CURRENT) {
[$cpp]           errorIfUnloaded();
[$cpp]           setParent( _parent );
[$cpp]           setChild(  _child  );
[$cpp]       }
#end


COPYOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} to inject an "ome.model" object into this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public void copyObject(ome.util.Filterable model, ome.util.ModelMapper _mapper) {
[$jav]            omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]            if (model instanceof ${type.id}) {
[$jav]                ${type.id} source = (${type.id}) model;
[$jav]                this.loaded = source.isLoaded();
[$jav]                Long id = (Long) mapper.findTarget( source.getId() );
[$jav]                this.setId( id == null ? new omero.RLong() : new omero.RLong(id) );
[$jav]                // Following also copy counts, etc. if necessary
[$jav]                if (!source.isLoaded()) {
[$jav]                    this.unload();
[$jav]                } else {
#if( ! $type.immutable )
[$jav]             this.version = source.getVersion() == null ? null : new omero.RInt( source.getVersion() );
#end
#foreach($property in $type.propertyClosure)
[$jav]                    this.copy${property.nameCapped}( source, mapper );
#end##FOREACH
[$jav]               }
[$jav]             } else {
[$jav]                throw new IllegalArgumentException(
[$jav]                  "${type.shortname} cannot copy from " +
[$jav]                  (model==null ? "null" : model.getClass().getName()));
[$jav]             }
[$jav]       }

FILLOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} produce an "ome.model" object from this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public ome.util.Filterable fillObject(ome.util.ReverseModelMapper _mapper) {
[$jav]           omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]           $type.id target = new ${type.id}();
[$jav]           mapper.store(this, target);
[$jav]           if (!this.loaded) {
[$jav]             target.setId( id == null ? null : id.val );
[$jav]             target.unload();
[$jav]           } else {
[$jav]             omero.RLong id = this.getId();
[$jav]             target.setId( id == null ? null : Long.valueOf(id.val) ); // special property
#if( ! $type.immutable )
[$jav]             target.setVersion(  this.version == null ? null : this.version.val );
#end
[$jav]             
[$jav]             // Following also copy counts, etc. if necessary
#foreach($property in $type.propertyClosure)
[$jav]             this.fill${property.nameCapped}( target, mapper );
#end##FOREACH
[$jav]           }
[$jav]           return target;
[$jav]         }

MISCELLANEOUS METHODS BLOCK:
=====================================================================================================

[$jav]     /**
[$jav]      * Casts (without warning) the given list to a list of
[$jav]      * the current type.
[$jav]      * @throws ClassCastException
[$jav]      */
[$jav]     @SuppressWarnings("unchecked") public static List<${PojoI}> cast(List list) { return list; }

[$pyc]
[$pyc]       def ice_postUnmarshal(self):
[$pyc]           """
[$pyc]           Provides additional initialization once all data loaded
[$pyc]           """
[$pyc]           pass # Currently unused
[$pyc]
[$pyc]
[$pyc]       def ice_preMarshal(self):
[$pyc]           """
[$pyc]           Provides additional validation before data is sent
[$pyc]           """
[$pyc]           pass # Currently unused
[$pyc]
[$pyc]       def __getattr__(self, name):
[$pyc]           """
[$pyc]           Reroutes all access to object.field through object.getField() or object.isField()
[$pyc]           """
[$pyc]           field  = "_" + name
[$pyc]           capitalized = name[0].capitalize() + name[1:]
[$pyc]           getter = "get" + capitalized
[$pyc]           questn = "is" + capitalized
[$pyc]           if hasattr(self, field):
[$pyc]               if hasattr(self, getter):
[$pyc]                   method = getattr(self, getter)
[$pyc]                   return method()
[$pyc]               elif hasattr(self, questn):
[$pyc]                   method = getattr(self, questn)
[$pyc]                   return method()
[$pyc]           raise AttributeError("'%s' object has no attribute '%s' or '%s'" % (self.__class__.__name__, getter, questn))
[$pyc]
[$pyc]       def __setattr__(self, name, value):
[$pyc]           """
[$pyc]           Reroutes all access to object.field through object.getField(), with the caveat
[$pyc]           that all sets on variables starting with "_" are permitted directly.
[$pyc]           """
[$pyc]           if name.startswith("_"):
[$pyc]               self.__dict__[name] = value
[$pyc]               return
[$pyc]           else:
[$pyc]               field  = "_" + name
[$pyc]               setter = "set" + name[0].capitalize() + name[1:]
[$pyc]               if hasattr(self, field) and hasattr(self, setter):
[$pyc]                   method = getattr(self, setter)
[$pyc]                   return method(value)
[$pyc]           raise AttributeError("'%s' object has no attribute '%s'" % (self.__class__.__name__, setter))
[$pyc]

END DECLARATION BLOCK:
=====================================================================================================

[$jav] }
[$hdr]  };
[$hdr]  typedef IceUtil::Handle<${PojoI}> ${PojoI}Ptr;
[$hdr]

[$cpp]}}
[$hdr]}}
[$hdr] #endif // ${POJOI}_H
[$ice]     };
[$ice]   };
[$ice] };
[$ice] #endif // ${POJO}_ICE
[$pyc] _omero_model.${PojoI} = ${PojoI}
#stop

