#*
 *   $Id$
 * 
 *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 * 
 *#

Note: lines not prefixed with [...] will be omitted in the final product.
The other prefixes are used by blitz/build.xml to determine how this file
will be split. This is done because the individual velocity if/elseif's 
and sets are nearly identical.

Here we turn off all prefixes except for ice.  Since <>I files are
concrete implementations, they should only be generated for concrete
classes.

#set( $ALL = "all" )
#set( $all = "all" )
#set( $jav = "jav" )
#set( $cpp = "cpp" )
#set( $hdr = "hdr" )
#set( $ice = "ice" )
#if($pojo.classModifiers.contains("abstract"))
#set( $all = "abs" )
#set( $jav = "abs" )
#set( $cpp = "abs" )
#set( $hdr = "abs" )
#end

Copyright notice added to all files:
[$ALL] /*
[$ALL]  *   Generated by blitz/templates/resouces/combined.vm
[$ALL]  * 
[$ALL]  *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
[$ALL]  *   Use is subject to license terms supplied in LICENSE.txt
[$ALL]  * 
[$ALL]  */

[$jav] package omero.model;
[$jav] import  java.util.*;
[$jav] import  ome.conditions.*;
[$cpp] \\\#include <OMERO/Model.h>


VARIABLES:
#set($Pojo  = "${pojo.declarationName}")
#set($PojoI = "${Pojo}I")
#set($POJO  = "${Pojo.toUpperCase()}")
#set($POJOI = "${PojoI.toUpperCase()}")


DECLARATION BLOCK:

[$ice] #ifndef ${POJO}_ICE
[$ice] #define ${POJO}_ICE
[$ice] module omero { 
[$ice]   module model {

[$jav] public class ${PojoI} extends ${Pojo} 
[$jav]    implements ome.api.ModelBased {

[$hdr] #ifndef ${POJOI}_H
[$hdr] #define ${POJOI}_H
[$hdr]
[$hdr] namespace omero { 
[$hdr]   namespace model {
[$hdr]     class ${PojoI} : public ${Pojo} { 

[$cpp] namespace omero { 
[$cpp]   namespace model {

[$hdr]     protected://------------------------------------------

INTERNAL METHODS:

[$hdr]       void preGetter(std::string field);
[$cpp]       void ${PojoI}::preGetter(std::string field)
[$cpp]       { errorIfUnloaded();}
[$jav]       protected void preGetter( String field )
[$jav]       { errorIfUnloaded();}

[$hdr]       void postGetter(std::string field);
[$cpp]       void ${PojoI}::postGetter(std::string field) {}
[$jav]       protected void postGetter( String field ) {}

[$hdr]       void preSetter(std::string field);
[$cpp]       void ${PojoI}::preSetter(std::string field)
[$cpp]       { errorIfUnloaded();}
[$jav]       protected void preSetter( String field, Object value )
[$jav]       {errorIfUnloaded();}

[$hdr]       void postSetter(std::string field);
[$cpp]       void ${PojoI}::postSetter(std::string field) {}
[$jav]       protected void postSetter( String field, Object value ) {}

[$hdr]       void errorIfUnloaded() throw(omero::UnloadedEntityException);
[$cpp]       void ${PojoI}::errorIfUnloaded() throw(omero::UnloadedEntityException)
[$cpp]       {
[$cpp]         if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
[$cpp]       }
[$jav]       protected void errorIfUnloaded() throws omero.UnloadedEntityException
[$jav]       {
[$jav]         if ( ! loaded ) throw new omero.UnloadedEntityException("Object unloaded:"+this);
[$jav]       }

[$hdr]       void throwNullCollectionException(std::string propertyName) throw(omero::UnloadedCollectionException);
[$cpp]       void ${PojoI}::throwNullCollectionException(std::string propertyName) throw(omero::UnloadedCollectionException)
[$cpp]       {
[$cpp]         throw omero::UnloadedCollectionException(
[$cpp]            __FILE__,__LINE__,
[$cpp]            "Error updating collection:" + propertyName +"\n"+
[$cpp]            "Collection is currently null. This can be seen\n"+
[$cpp]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$cpp]            "that this collection was unloaded. Please refresh this object\n"+
[$cpp]            "in order to update this collection.\n");
[$cpp]       }
[$jav]       protected void throwNullCollectionException(String propertyName) throws omero.UnloadedCollectionException
[$jav]       {
[$jav]          throw new omero.UnloadedCollectionException(
[$jav]            "Error updating collection:" + propertyName +"\n"+
[$jav]            "Collection is currently null. This can be seen\n"+
[$jav]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$jav]            "that this collection was unloaded. Please refresh this object\n"+
[$jav]            "in order to update this collection.\n"
[$jav]            );
[$jav]       }

DESTRUCTOR BLOCK:

[$hdr]       virtual ~${PojoI}(); // protected as outlined in docs.
[$cpp]     ${PojoI}::~${PojoI}() {}


[$hdr]     public://---------------------------------------------


DEFAULT CONSTRUCTOR BLOCK:

[$all]   /**
[$all]    * Default no-args constructor which manages the proper "loaded"
[$all]    * status of all {@link Collection}s by manually initializing them all
[$all]    * to an empty {@link Collection} of the approrpriate type.
[$all]    */

[$jav]     public ${PojoI}() {
[$hdr]     ${PojoI}();
[$cpp]     ${PojoI}::${PojoI}() {
[$cpp]         loaded = true;
[$cpp]         toggleCollectionsLoaded(true);
[$jav]         loaded = true;
[$jav]         toggleCollectionsLoaded(true);
[$jav]    }
[$cpp]    }

TOGGLE COLLECTIONS:

[$jav]    public void toggleCollectionsLoaded(boolean load) {
[$hdr]    void toggleCollectionsLoaded(bool load);
[$cpp]    void ${PojoI}::toggleCollectionsLoaded(bool load) {
#foreach( $property in $pojo.propertyClosureForFullConstructor)
#set(     $name = $pojo.getPropertyName($property))
#set(     $javaType = $c2j.getJavaTypeName($property,false))##generics
#set(     $seqName = "${Pojo}${name.substring(0,1).toUpperCase()}${name.substring(1,$name.length())}Seq" )## seqName copied from ice_defs.vm
#set(     $genericType = $c2j.getJavaTypeName($property,true) )
#if(      $genericType.contains("ome.model") )
#set(     $genericType = $genericType.replaceFirst(".*<ome.model..+?[.]","omero::model::").replaceFirst(">.*","") )
#end

Here we don't have to keep up with the type (set/list)
since all collections are lists in ice.

#if(      $fulltype.contains("byte[]"))
[$ice]     sequence<byte> ${seqName};

#elseif(  $javaType.startsWith("java.util.Set") || $javaType.startsWith("java.util.List"))
#set(     $genericTypeC = "${genericType.replaceAll('[.]','::')}")

[$ice]     ["java:type:java.util.ArrayList"] sequence<$genericTypeC> ${seqName};

[$jav]        if (load) { 
[$jav]          ${property.name} = new ArrayList(); 
[$jav]          ${property.name}Loaded = false;
[$jav]        } else { 
[$jav]          ${property.name} = null; 
[$jav]          ${property.name}Loaded = false;
[$jav]        }
[$cpp]        if (load) { 
[$cpp]          ${property.name} = ${seqName}(); 
[$cpp]          ${property.name}Loaded = true;
[$cpp]        } else { 
[$cpp]          ${property.name} = (${seqName})0;
[$cpp]          ${property.name}Loaded = false; 
[$cpp]        }
#end
#end
[$jav]    }
[$cpp]    }

ICE CLASS:

Calculate inheritance. This is done here because sequences must first be defined.

#set( $base = "extends omero::model::IObject" )
#set( $extendsDeclaration = $base )
#if(  $pojo.isSubclass() )
#set( $extendsDeclaration = $pojo.getExtendsDeclaration().replaceFirst("ome.model..+?[.]","omero::model::" ) )
#end

[$ice]     class ${pojo.declarationName}
[$ice]     $extendsDeclaration
[$ice]     {

UNLOADED CONSTRUCTOR BLOCK:

[$all]   /**
[$all]    * Id constructor which allows for the using instances as pointers.
[$all]    */
[$jav]    public ${PojoI}(long id, boolean loaded) {
[$jav]      this.id = new omero.RLong(false,id);
[$jav]      this.loaded = loaded; 
[$jav]    }
[$hdr]    ${PojoI}(omero::RLongPtr idPtr, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(omero::RLongPtr idPtr, bool isLoaded) {
[$cpp]      id = idPtr;
[$cpp]      loaded = isLoaded; 
[$cpp]      toggleCollectionsLoaded(isLoaded);
[$cpp]    }

UNLOAD BLOCK:

[$jav]    public void unload(Ice.Current current) {
[$hdr]    virtual void unload(const Ice::Current& current = Ice::Current() );
[$cpp]  void ${PojoI}::unload(const Ice::Current& current) {
[$jav]      loaded = false;
[$cpp]      loaded = false;
#foreach($property in $pojo.propertyClosureForFullConstructor)
#if(!$clazz.identifierProperty.equals($property))
#set( $PropertyName = $pojo.beanCapitalize( $property.name ) )
[$jav]      unload${PropertyName}( current );
[$cpp]      unload${PropertyName}( current );
#end
#end
[$jav]    }
[$cpp]    }

###########################################################################
#foreach($property in $pojo.propertyClosureForFullConstructor)#############
###########################################################################

ACCESSORS BLOCK:

Copied from pojo/PropertyAccessors.vm.
These mappings are from HibernateTypes-->IceTypes

Ice properties should only be defined once (not in every subclass, obviously).
However, because of Ice's inheritance structure, we are here using 
propertyClosureForFullConstructor which gives us superclass fields. These
must be filtered in the [Ice] sections below, but not for all others.

#set( $definedIn = "nothere" )
#foreach( $p2 in $pojo.allPropertiesIterator )
#if( $p2.name.equals($property.name) )
#set( $definedIn = "here" )
#end
#end
#set($Ice = "ice" )
#if( $definedIn.startsWith("not") )
#set($Ice = "NOT" )
#end

## UNIFY THESE
#set( $name = $pojo.getPropertyName($property))
#set( $field = $property.name )
#set( $PropertyName = $pojo.beanCapitalize( $property.name ) )
#set( $FIELD = ${field.toUpperCase()} )
#set( $javaType = $c2j.getJavaTypeName($property,false))##generics
#set( $shortType = $c2j.unqualify($javaType) )
#set( $open = " " )
#set( $close= " " )
#set( $prefix=" " )
#set( $suffix=" " )
#set( $unloadedJava=" " )
#set( $unloadedCpp=" " )
#set( $elementType = $c2j.getJavaTypeName($property,true).replaceFirst(".*<","").replaceFirst(">.*",""))
#set( $elementName = $c2j.unqualify( $elementType ) )
#set( $seqName = "${Pojo}${name.substring(0,1).toUpperCase()}${name.substring(1,$name.length())}Seq" )## seqName copied from ice_defs.vm
#set( $propLoaded = "${property.Name}Loaded" )

#if( $javaType.startsWith("ome"))##JAVA_TYPE
#set( $javaType = "omero.model.${shortType}" )
#set( $getter = "(omero.model.${shortType}) this.$property.name" )
#set( $setter = "${property.name}")
#set( $cppType = "omero::model::${shortType}Ptr" )

#elseif( $javaType.startsWith("IObject"))
#set( $javaType = "omero.model.IObject")
#set( $getter = "(omero.model.IObject) this.$property.name" )
#set( $setter = "${property.name}")
#set( $cppType = "omero::model::IObjectPtr")

#elseif( $javaType.startsWith("java.util.List"))
#set( $getter = "new java.util.ArrayList( ${property.name} == null ? new java.util.ArrayList() : this.$property.name ) " )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : $property.name " ) ## TODO or just null?
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} > ($cppType) 0) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )

#elseif( $javaType.startsWith("java.util.Set"))
#set( $getter = "new java.util.HashSet( ${property.name} == null ? new java.util.ArrayList() : this.$property.name )" )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( $property.name ) " ) ## TODO or just null?
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} > ($cppType) 0) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )

#elseif( $javaType.startsWith("java.lang.Boolean"))
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RBool(true,false) : new omero.RBool(false,${property.name}) ")
#set( $cppType   = "omero::RBoolPtr" )

#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RInt(true,0) : new omero.RInt(false,${property.name}) ")
#set( $cppType   = "omero::RIntPtr" )

#elseif( $javaType.startsWith("java.lang.Long"))
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RLong(true,0L) : new omero.RLong(false,${property.name}) ")
#set( $cppType   = "omero::RLongPtr" )

#elseif( $javaType.startsWith("java.lang.Double"))
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RDouble(true,0.0) : new omero.RDouble(false,${property.name}) ")
#set( $cppType   = "omero::RDoublePtr" )

#elseif( $javaType.startsWith("java.lang.Float"))
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RFloat(true,0f) : new omero.RFloat(false,${property.name}) ")
#set( $cppType   = "omero::RFloatPtr" )

#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "Long" )
#set( $getter   = "new Long(this.$property.name)" )
#set( $setter = "(${property.name} == null) ? 0 : this.$property.name == ${property.name}.longValue()")
#set( $cppType = "long" )

#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : new java.sql.Timestamp( ${property.name}.val.val )" )
#set( $setter = "${property.name} == null ? new omero.RTime(true,null) : new omero.RTime(false,new omero.Time(${property.name}.getTime()))");
#set( $cppType = "omero::RTimePtr" )

#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $getter = "${property.name} == null ? null : ${property.name}._null ? null : ${property.name}.val" )
#set( $setter = "${property.name} == null ? new omero.RString(true,null) : new omero.RString(false,${property.name}) ")
#set( $cppType = "omero::RStringPtr" )

#else
[$all]...ERROR...$javaType unknown.

#end##JAVA_TYPE

ICE BLOCK:

// $property
#if($clazz.identifierProperty.equals($property))
             // Id in IObject
#elseif($field.equals("details"))
             // Details in IObject
#elseif($field.equals("version"))
#if($extendsDeclaration.equals($base))
[$Ice]       // Version in superclass
[$Ice]       omero::RInt version;
#end
#elseif( ${shortType} == "String")
[$Ice]       omero::RString ${property.name};
#elseif( ${shortType} == "Boolean" )
[$Ice]       omero::RBool ${property.name};
#elseif ( ${shortType} == "Double" )
[$Ice]       omero::RDouble ${property.name};
#elseif ( ${shortType} == "Float" )
[$Ice]       omero::RFloat ${property.name};
#elseif( ${shortType} == "Integer")
[$Ice]       omero::RInt ${property.name};
#elseif ( ${shortType} == "Long" )
[$Ice]       omero::RLong ${property.name};
#elseif ($javaType.startsWith("ome") )## Had to be moved before "*Map" rule
[$Ice]       omero::model::${shortType} ${property.name};
#elseif ($javaType.equals("IObject"))## Special case of the previous
[$Ice]       omero::model::IObject ${property.name};
#elseif ($shortType.endsWith("Map") )
[$Ice]       dictionary ${property.name};
#elseif( $javaType.contains("java.util.List") || $javaType.contains("java.util.Set") || $javaType.contains("[]")) 
[$Ice]       $seqName ${property.name};
[$Ice]       bool ${property.name}Loaded;
#elseif ($javaType.equals("java.sql.Timestamp"))
[$Ice]       omero::RTime ${property.name};
#elseif ($javaType.equals("long")) ## From Permissions
[$Ice]       long ${field};
#else
[$Ice]       ERROR ===========> Unknown type (${javaType})
#end // End type


ASSOCIATION TYPES BLOCK:

#set( $hasSet  = $c2j.hasMetaAttribute($property, "set-add-method"))
#set( $hasLink = $c2j.hasMetaAttribute($property, "link-add-method") )

#set( $access = "protected" )
#set( $unloadIfIsSet = "${property.Name}Loaded = false;")
#if( !$hasSet && !$hasLink)
#set( $access = "public" )
#set( $unloadIfIsSet = "");
#end

Unload

[$Ice]      void unload${PropertyName}();
[$jav]    public void unload${PropertyName}(Ice.Current current) {
[$jav]      ${unloadIfIsSet}
[$jav]      ${property.name} = null;
[$jav]    }
[$hdr]      void unload${PropertyName}(const Ice::Current& current);
[$cpp]    void ${Pojo}I::unload${PropertyName}(const Ice::Current& current) {
[$cpp]      ${unloadIfIsSet}
[$cpp]      ${property.name} = ($cppType) 0;
[$cpp]    }

Original accessors: will have their visibility reduced if
the special set methods are added.

[$jav]    $access $javaType $pojo.getGetterSignature($property)() 
[$jav]    throws omero.UnloadedEntityException {
[$jav]        errorIfUnloaded();
[$jav]        return $getter;
[$jav]    }
[$jav]    
[$jav]    $access void set$name($javaType $property.Name)
[$jav]    throws omero.UnloadedEntityException {
[$jav]        errorIfUnloaded();
[$jav]        this.$property.Name = $setter;
[$jav]        $unloadedJava
[$jav]    }

[$hdr]  $access:
[$hdr]    $cppType $pojo.getGetterSignature($property)();
[$hdr]    void set$name($cppType _$property.Name);
[$hdr]  public:

[$cpp]    $cppType ${PojoI}::$pojo.getGetterSignature($property)() {
[$cpp]        errorIfUnloaded();
[$cpp]        return ${open}${property.name}${close};
[$cpp]    }
[$cpp]    
[$cpp]    void ${PojoI}::set$name($cppType _$property.Name) {
[$cpp]        errorIfUnloaded();
[$cpp]        $property.Name = $!{prefix}_${property.Name}$!{suffix};
[$cpp]        $unloadedCpp
[$cpp]    }

One-to-many extras:

#if( $hasSet || $hasLink )

[$Ice]    long sizeOf${PropertyName}(); // throws omero::UnloadedEntityException 
[$jav]    public long sizeOf${PropertyName}(Ice.Current current) throws omero.UnloadedEntityException {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$jav]      return ${property.name}.size();
[$jav]    }
[$hdr]    long sizeOf${PropertyName}( const Ice::Current& current = Ice::Current() ) throw(omero::UnloadedEntityException);
[$cpp]    long ${PojoI}::sizeOf${PropertyName}( const Ice::Current& current ) throw(omero::UnloadedEntityException) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]      return ${property.name}.size();
[$cpp]    }

[$jav]    public Iterator iterate${PropertyName}(){
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) {
[$jav]        throwNullCollectionException("${property.name}");
[$jav]      }
[$jav]      return get${PropertyName}().iterator();
[$jav]    }
[$hdr]    $cppType::iterator begin${PropertyName}();
[$hdr]    $cppType::iterator end${PropertyName}();
[$cpp]    $cppType::iterator ${PojoI}::begin${PropertyName}(){
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) {
[$cpp]        throwNullCollectionException("${property.name}");
[$cpp]      }
[$cpp]      return ${property.name}.begin();
[$cpp]    }
[$cpp]    $cppType::iterator ${PojoI}::end${PropertyName}(){
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) {
[$cpp]        throwNullCollectionException("${property.name}");
[$cpp]      }
[$cpp]      return ${property.name}.end();
[$cpp]    }

[$jav]    public List<$javaType> copy${PropertyName}() {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$jav]      List<$javaType> result = new ArrayList(${property.name});
[$jav]      return result;
[$jav]    }

         Here we don't have a vector<$cppType> since the type is typedef'd
[$hdr]    $cppType copy${PropertyName}();
[$cpp]    $cppType ${PojoI}::copy${PropertyName}(){
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${property.name}");
[$cpp]      $cppType result(${property.name}.size());
[$cpp]      std::copy(${property.name}.begin(), ${property.name}.end(), result.begin());
[$cpp]      return result;
[$cpp]    }

#end


------------------------------------------------------------
Because of the ice inheritance hierarchy, we must use direct
field access on several methods below.
------------------------------------------------------------

Set modifications:

#if( $hasSet )
#set( $inverse = $c2j.getMetaAsString($property, "set-add-method"))
#set( $Inverse = $pojo.beanCapitalize( $inverse) )

add single

[$jav]    public void add${elementName}(${elementName} target) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      get${PropertyName}().add( target );
[$jav]      target.$inverse = this;
[$jav]    }
[$hdr]    void add${elementName}(${elementName}Ptr target);
[$cpp]    void ${PojoI}::add${elementName}(${elementName}Ptr target) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      get${PropertyName}().push_back( target );
[$cpp]      target->$inverse = this;
[$cpp]    }

add set

[$jav]    public void add${elementName}Set(Collection<${elementName}> targets) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      get${PropertyName}().addAll( targets );
[$jav]      for( ${elementName} target : targets) {
[$jav]        target.$inverse = this;
[$jav]      }
[$jav]    }
[$hdr]    void add${elementName}Set($cppType targets);
[$cpp]    void ${PojoI}::add${elementName}Set($cppType targets) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      $cppType::iterator loc = get${PropertyName}().end();
[$cpp]      $cppType::iterator beg = targets.begin(); 
[$cpp]      $cppType::iterator end = targets.end(); 
[$cpp]      get${PropertyName}().insert(loc,beg,end);
[$cpp]      for ($cppType::iterator it = targets.begin(); it != targets.end(); ++it) {
[$cpp]        ${elementName}Ptr target = *it;
[$cpp]        target->$inverse = this;
[$cpp]      } 
[$cpp]    }

remove single

#set( $removePredicate = "testRemove${elementName}From${PojoI}" )
[$cpp] struct $removePredicate
[$cpp] {
[$cpp]     const ${elementName}Ptr t;
[$cpp]     ${removePredicate}(const ${elementName}Ptr n) : t(n) {}
[$cpp]     bool operator()(${elementName}Ptr const& o) {
[$cpp]         return o == t;
[$cpp]     }
[$cpp] 
[$cpp] };

[$jav]    public void remove${elementName}(${elementName} target) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      get${PropertyName}().remove( target );
[$jav]      target.$inverse = null;
[$jav]    }
[$hdr]    void remove${elementName}(${elementName}Ptr target);
[$cpp]    void ${PojoI}::remove${elementName}(${elementName}Ptr target) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      $cppType::iterator it = std::remove_if(
[$cpp]        ${property.name}.begin(),
[$cpp]        ${property.name}.end(),
[$cpp]        ${removePredicate}(target));
[$cpp]      ${property.name}.erase(it,${property.name}.end());
[$cpp]      target->$inverse = (${PojoI}Ptr)0;
[$cpp]    }

remove multiple

#set( $removeSetPredicate = "testRemove${elementName}SetFrom${PojoI}" )
[$cpp] struct ${removeSetPredicate}
[$cpp] {
[$cpp]     const ${cppType} t;
[$cpp]     ${removeSetPredicate}(const ${cppType} n) : t(n) {}
[$cpp]     bool operator()(${elementName}Ptr const& o) {
[$cpp]         return std::find(t.begin(), t.end(), o) != t.end();
[$cpp]     }
[$cpp] 
[$cpp] };


[$jav]    public void remove${elementName}Set(Collection<${elementName}> targets) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      for( ${elementName} elt : targets) {
[$jav]        elt.$inverse = null;
[$jav]        ${property.name}.remove( elt );
[$jav]      }
[$jav]    }
[$hdr]    void remove${elementName}Set($cppType targets);
[$cpp]    void ${PojoI}::remove${elementName}Set($cppType targets) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      ${cppType}::iterator end = ${property.name}.end(); 
[$cpp]      ${cppType}::iterator removed = std::remove_if(
[$cpp]        ${property.name}.begin(), end,
[$cpp]        $removeSetPredicate(targets));
[$cpp]      ${cppType}::iterator beg(removed);
[$cpp]      for(; beg != end; beg++) {
[$cpp]        (*beg)->$inverse = (${PojoI}Ptr)0; 
[$cpp]      }
[$cpp]      ${property.name}.erase(removed,end);
[$cpp]    }

clear

[$jav]    public void clear${PropertyName}() {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      for( ${elementName} elt : (Collection<${elementName}>)${property.name}) {
[$jav]        elt.$inverse = null;
[$jav]      }
[$jav]      ${property.name}.clear();
[$jav]    }
[$hdr]    void clear${PropertyName}();
[$cpp]    void ${PojoI}::clear${PropertyName}() {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      $cppType::iterator beg = ${property.name}.begin();
[$cpp]      $cppType::iterator end = ${property.name}.end();
[$cpp]      for(; beg != end; beg++) {
[$cpp]        (*beg)->$inverse = (${PojoI}Ptr)0;
[$cpp]      }
[$cpp]      ${property.name}.clear();
[$cpp]    }

Link Modifications

#elseif( $hasLink )

Here our "elements" from the above are the links which themselves
have linked elements.

#set( $linkedType = $c2j.getMetaAsString($property, "link-add-method"))
#set( $linkedName = $c2j.unqualify( $linkedType ) )
#set( $LinkType = $elementType )
#set( $Link = $c2j.unqualify( $LinkType ) )
#set( $order = $c2j.getMetaAsString($property, "link-add-order"))
#set( $next = $c2j.getMetaAsString($property, "link-add-next"))
#set( $other = $c2j.getMetaAsString($property, "link-add-other"))
#set( $bidir = $c2j.getMetaAsBool($property, "link-add-bidir"))

[$jav]    public void link${linkedName}(${linkedName} addition) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      ${Link}I link = new ${Link}I();
[$jav]      link.link( ${order} );
[$jav]      add${Link}( link, true );
[$jav]    }
[$hdr]    void link${linkedName}(${linkedName}Ptr addition);
[$cpp]    void ${PojoI}::link${linkedName}(${linkedName}Ptr addition) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      ${Link}IPtr link = new ${Link}I();
[$cpp]      link->link( ${order} );
[$cpp]      add${Link}( link, true );
[$cpp]    }

TODO: do we need to do link.parent = ...;

[$jav]    public void add${Link}(${Link} link, boolean bothSides) {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      ${property.name}.add( link );
#if($bidir)
TODO: Should we check for nulls in other?
[$jav]      if (bothSides && link.${other}.loaded ) {
[$jav]        ((${linkedName}I)link.${other}).add${Link}( link, false );
[$jav]      }
#end
[$jav]    }
[$hdr]    void add${Link}(${Link}Ptr link, bool bothSides);
[$cpp]    void ${PojoI}::add${Link}(${Link}Ptr link, bool bothSides) {
[$cpp]      errorIfUnloaded();
[$cpp]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$cpp]      ${property.name}.push_back( link );
#if($bidir)
[$cpp]      if (bothSides && link->${other}->loaded ) {
[$cpp]        ${linkedName}IPtr::dynamicCast(link->${other})->add${Link}( link, false );
[$cpp]      }
#end
[$cpp]    }

[$jav]    public Iterator<${linkedName}> linked${linkedName}Iterator() {
[$jav]      errorIfUnloaded();
[$jav]      if (!${propLoaded}) throwNullCollectionException("${name}");
[$jav]      return null;
[$jav]    }
[$hdr]    std::vector<${linkedName}Ptr>::iterator linked${linkedName}();
[$cpp]    std::vector<${linkedName}Ptr>::iterator ${PojoI}::linked${linkedName}() {
[$cpp]      errorIfUnloaded();
[$cpp]      std::vector<${linkedName}Ptr>::iterator result;
[$cpp]      return result;
	TODO------------
[$cpp]    }


#end

##################################################################
#end##FOREACH#####################################################
##################################################################

CLASS-LEVEL EXTRA METHODS:

#if( $c2j.hasMetaAttribute($clazz, "link-parent") )
#set( $parent = $c2j.unqualify( $c2j.getMetaAsString($clazz, "link-parent")))
#set( $child =  $c2j.unqualify( $c2j.getMetaAsString($clazz, "link-child" )))

TODO: Should these be <>I or not?

[$jav] public void link(${parent} parent, ${child} child) {
[$jav]   errorIfUnloaded();
[$jav]   setParent( parent );
[$jav]   setChild( child );
[$jav] }
[$jav] public ${parent} parent() {
[$jav]   errorIfUnloaded();
[$jav]   return (${parent}) parent;
[$jav] }
[$jav] public ${child}I child() {
[$jav]   errorIfUnloaded();
[$jav]   return (${child}I) child;
[$jav] }
[$hdr] void link(${parent}Ptr parent, ${child}Ptr child);
[$hdr] ${parent}Ptr castParent();
[$hdr] ${child}Ptr castChild();
[$cpp] void ${PojoI}::link(${parent}Ptr parent, ${child}Ptr child) {
[$cpp]   errorIfUnloaded();
[$cpp]   setParent( parent );
[$cpp]   setChild(  child  );
[$cpp] }
[$cpp] ${parent}Ptr ${PojoI}::castParent() {
[$cpp]   errorIfUnloaded();
[$cpp]   return ${parent}Ptr::dynamicCast( getParent() );
[$cpp] }
[$cpp] ${child}Ptr ${PojoI}::castChild() {
[$cpp]   errorIfUnloaded();
[$cpp]   return ${child}Ptr::dynamicCast( getChild() );
[$cpp] }
#end


COPYOBJECT BLOCK:

[$jav]    public void copyObject(ome.util.Filterable model, ome.util.ModelMapper _mapper) {
[$jav]         omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]         if (model instanceof $pojo.qualifiedDeclarationName){
[$jav]             $pojo.qualifiedDeclarationName source = ($pojo.qualifiedDeclarationName) model;
[$jav]             this.loaded = source.isLoaded();

#foreach($property in $pojo.propertyClosureForFullConstructor)
#set( $name = $pojo.getPropertyName($property))
#set( $javaType = $c2j.getJavaTypeName($property,false))##generics
#set( $shortType = $c2j.unqualify($javaType) )
#set( $method = "source.get$name()" )
#set( $guard  = "if (this.loaded) " )
#if($clazz.identifierProperty.equals($property))
#set( $guard  = "" )
#end

#if( $pojo.qualifiedDeclarationName.startsWith("ome.model.internal.Permissions") )
#set( $javaType = "Long" )
#set( $method = "ome.util.Utils.internalForm(source)" )
#elseif( $javaType.startsWith("ome") )
#set( $javaType = "omero.model.${shortType}" )
#elseif( $javaType.startsWith("IObject") )
#set( $javaType = "omero.model.IObject" )
#elseif( $javaType.startsWith("long"))
#set( $javaType = "Long")
#elseif( $javaType.startsWith("java.util.Set") || $javaType.startsWith("java.util.List") )
## If this is the case, we can't use the accessor and have to use a generated method
#set( $method = "source.retrieve(${pojo.qualifiedDeclarationName}.${name.toUpperCase()})" )
#end

[$jav]              $guard this.set$name(($javaType) mapper.findTarget($method));

#end

[$jav]     } else {
[$jav]              throw new IllegalArgumentException(
[$jav]                "${pojo.declarationName} cannot copy from " + 
[$jav]                (model==null ? "null" : model.getClass().getName()));
[$jav]     }
[$jav]     }

FILLOBJECT BLOCK:

[$jav]     public ome.util.Filterable fillObject(ome.util.ReverseModelMapper _mapper) {
[$jav]         omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]         $pojo.qualifiedDeclarationName target = new ${pojo.qualifiedDeclarationName}();
[$jav]         mapper.store(this, target);
[$jav]         if (!this.loaded) {
[$jav]           target.setId( id == null ? null : id._null ? null : id.val );
[$jav]           target.unload();
[$jav]         } else {

#foreach($property in $pojo.propertyClosureForFullConstructor)
#set( $name = $pojo.getPropertyName($property))
#set( $javaType = $c2j.getJavaTypeName($property,false))##generics
#set( $shortType = $c2j.unqualify($javaType) )
#set( $FIELD = "${pojo.qualifiedDeclarationName}.${name.toUpperCase()}" )
#set( $propLoaded = "${property.Name}Loaded" )

#if( $pojo.qualifiedDeclarationName.startsWith("ome.model.internal.Permissions") )
[$jav]           target = ome.util.Utils.toPermissions((Long)this.getPerm1());

#elseif( $javaType.startsWith("ome") )
[$jav]           target.putAt($FIELD, ($javaType) mapper.reverse( (ome.api.ModelBased) this.get$name() ) );

#elseif( $javaType.startsWith("IObject") )
[$jav]           target.set$name( (ome.model.IObject) mapper.reverse( (ome.api.ModelBased) this.get$name() ) );

#elseif( $javaType.startsWith("java.util.Set") || $javaType.startsWith("java.util.List") )
## If this is the case, we can't use the accessor and have to use a generated method

[$jav]           if (this.${propLoaded}) {
[$jav]             target.putAt( $FIELD, mapper.reverse( this.get$name() ) );
[$jav]           } else {
[$jav]             target.putAt( $FIELD, null );
[$jav]           }

#elseif( $javaType.startsWith("long"))
 ----------------> ERROR
#else
                target.set$name( this.get$name() );
#end
#end

[$jav]       }
[$jav]             return target;
[$jav]     }


END DECLARATION BLOCK:

[$jav] }
[$hdr]  };
[$hdr]  typedef IceUtil::Handle<${PojoI}> ${PojoI}Ptr;
[$hdr]  

[$cpp]}}
[$hdr]}}
[$hdr] #endif // ${POJOI}_H
[$ice] };};};
[$ice] #endif // ${POJOI}_ICE

#stop

