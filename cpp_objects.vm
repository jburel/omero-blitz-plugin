#*
 *   $Id$
 * 
 *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 * 
 *#
/*
 *   \$Id\$
 * 
 *   Copyright 2007 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 * 
 */



// Generated by templates/cpp_objects.vm

#if(!$pojo.classModifiers.contains("abstract")) ####################### ONLY IF NOT ABSTRACT

namespace omero { namespace model {

    ${pojo.declarationName}I::~${pojo.declarationName}I() {}
    ${pojo.declarationName}I::${pojo.declarationName}I() {
        loaded = true;
########################################################
#foreach( $property in $pojo.propertyClosureForFullConstructor())
#set(     $name = $pojo.getPropertyName($property))
#set(     $javaType = $c2j.getJavaTypeName($property,false))##generics
#set(     $seqName = "${pojo.declarationName}${name.substring(0,1).toUpperCase()}${name.substring(1,$name.length())}Seq" )## seqName copied from ice_defs.vm
#if(      $javaType.startsWith("java.util.Set") )
##
        set${name}($seqName());
##
#elseif(  $javaType.startsWith("java.util.List") )
## 
        set${name}($seqName());
##
#end
#end
########################################################
    }

  ${pojo.declarationName}I::${pojo.declarationName}I(omero::RLongPtr idPtr, bool isLoaded) {
    id = idPtr;
    loaded = isLoaded; 
  }


  void ${pojo.declarationName}I::unload(const Ice::Current& c) {
#foreach($property in $pojo.propertyClosureForFullConstructor())
#set( $field = "${property.name}")
#set( $seqName = "${pojo.declarationName}${field.substring(0,1).toUpperCase()}${field.substring(1,$field.length())}Seq" )## seqName copied from ice_defs.vm
#set( $name = $pojo.getPropertyName($property) )
#set( $javaType = $c2j.getJavaTypeName($property,false))##generics
#set( $shortType = $c2j.unqualify($javaType) )
#if(!$clazz.identifierProperty.equals($property))
## IF JAVA_TYPE (see copy() method below)
#if( $javaType.startsWith("ome"))
#set( $javaType = "omero::model::${shortType}Ptr" )
#elseif( $javaType.startsWith("IObject"))
#set( $javaType = "omero::model::IObjectPtr")
#elseif( $javaType.startsWith("java.util.List"))
#set( $javaType = "$seqName" )
#set( $prefix = "${property.name} == 0 ? 0 /*FIXME*/ : " ) ## TODO or just null?
#set( $unloadedstmt = "if (${property.name} > 0) { ${property.Name}Loaded = true; } else { ${property.Name}Loaded = false; }" )
#elseif( $javaType.startsWith("java.util.Set"))
#set( $javaType = "$seqName" )
#set( $prefix = "${property.name} == 0 ? 0 /*FIXME*/ : " ) ## TODO or just null?
#set( $unloadedstmt = "if (${property.name} > 0) { ${property.Name}Loaded = true; } else { ${property.Name}Loaded = false; }" )
#elseif( $javaType.startsWith("java.lang.Boolean"))
#set( $javaType   = "omero::RBoolPtr" )
#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $javaType   = "omero::RIntPtr" )
#elseif( $javaType.startsWith("java.lang.Long"))
#set( $javaType   = "omero::RLongPtr" )
#elseif( $javaType.startsWith("java.lang.Double"))
#set( $javaType   = "omero::RDoublePtr" )
#elseif( $javaType.startsWith("java.lang.Float"))
#set( $javaType   = "omero::RFloatPtr" )
#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "long" )
#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $javaType = "omero::RTimePtr" )
#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $javaType = "omero::RStringPtr" )
#else
ERROR ========> $property
#end ##END JAVA_TYPE
      set$name( ($javaType) 0 );
#end
#end	
      loaded = false;

    }

} }

#end############################################################## ONLY IF NOT ABSTRACT
#stop

 // Allow overriding of getter and setter logic.
 
 protected void ${pojo.declarationName}I::errorIfUnloaded()
	{
	  if (!loaded) {
	    throw "Object is not loaded".
	  }
	}

protected void ${pojo.declarationName}I::throwNullCollectionException(String propertyName)
	{
	  throw 
		  "Error updating collection:" + propertyName +"\n"+
		  "Collection is currently null. This can be seen\n"+
		  "by testing \"sizeOf"+ propertyName +" < 0\". This implies\n"+
		  "that this collection was unloaded. Please refresh this object\n"+
		  "in order to update this collection.\n";
	}

	// Property accessors
#foreach($property in $pojo.propertyClosureForFullConstructor)
#set( $PropertyName = $pojo.beanCapitalize( $property.name ) )
#set( $fieldtype =  $pojo.getJavaTypeName($property, $jdk5) )
#set( $elementtype = $c2j.getJavaTypeName($property,true).replaceFirst(".*<","").replaceFirst(">.*",""))
#set( $Name = $c2j.unqualify( $elementtype ) )
#set( $field = $property.name )
#set( $FIELD = ${field.toUpperCase()} )
#if( $c2j.hasMetaAttribute($property, "set-add-method") || $c2j.hasMetaAttribute($property, "link-add-method") )

/**
 * returns ${property.name} . You should not modify this Set unless you
 * know what you are doing. Use the iterate method instead.
 */
protected $fieldtype ${pojo.declarationName}I::get${PropertyName}() {
  errorIfUnloaded();
  return ${property.name};
}

/**
 * setter for ${property.name} should be avoided. Does not fulfill normal semantics.
 */
protected void ${pojo.declarationName}I::set${PropertyName}($fieldtype ${property.name}) {
  errorIfUnloaded();
  ${property.name} = ${property.name};
}

/**
 * returns the size of ${property.name}. If less than zero, the Set was null.
 */
public int ${pojo.declarationName}I::sizeOf${PropertyName}() {
  errorIfUnloaded();
  return; // FIXME ${property.name} == null ? -1 : this.${property.name}.size();
}

/**
 * should be used rather than accessing the ${property.name} set directly.
 * This method will never return null, but rather will return an instance
 * of {@link ome.util.EmptyIterator}. To test for a null collection,
 * see of {@link #sizeOf${PropertyName}()} is less than zero.
 */
public Iterator ${pojo.declarationName}I::iterate${PropertyName}() {
  errorIfUnloaded();
  if ( get${PropertyName}() == null )
    {
      return new ome.util.EmptyIterator();
    }
  return get${PropertyName}().iterator();
}

/**
 * takes a CBlock and calls the block once for each $elementtype while
 * collecting the results. If <code>block == null</code>, then the
 * iterator values themselves are collected. This method uses
 * {@link #iterate${PropertyName}} internally and so will return a value
 * even if the underlying collection is null.
 */
public List ${pojo.declarationName}I::collect${PropertyName}(ome.util.CBlock block) {
  errorIfUnloaded();
  
    		List result = new ArrayList();
    		Iterator it = iterate${PropertyName}();
    		while ( it.hasNext() )
    		{
    			IObject obj = (IObject) it.next();
    			if ( block != null )
    			{
    				result.add( block.call( obj ) );
    			} else {
    				result.add( obj );
    			}

    		}
    		return result;

		} finally {
			postGetter( $FIELD );
		}

	}

#end
##
## SETS: These methods represent our handling of Hibernate's "inverse" sets
##       which do not act as expected with regards to getters & setters.
##
#if( $c2j.hasMetaAttribute($property, "set-add-method") )
#set( $inverse = $pojo.beanCapitalize( $c2j.getMetaAsString($property, "set-add-method")))
	/**
	 * use instead of set${PropertyName} . Makes the necessary
	 * call on $elementtype as well.
	 */
	public void add${Name}($elementtype target) {

		try {
			preSetter( $FIELD, target );

    		if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

    		get${PropertyName}().add( target );
    		target.set${inverse} ( this );

		} finally {
			postSetter( $FIELD, target );
		}

	}

	/**
	 * use like add${Name}.
	 */
	public void add${Name}Set(Set targets) {

		try {
			preSetter( $FIELD, targets );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

    		get${PropertyName}().addAll( targets );
    		Iterator it = targets.iterator();
    		while ( it.hasNext() )
    		{
    		  $elementtype target = ($elementtype) it.next();
    		  target.set${inverse} ( this );
    		}

		} finally {
			postSetter( $FIELD, targets );
		}

	}

	/**
	 * removes a single element from this set and makes the inverse call on ${elementtype}
	 */
	public void remove${Name}(${elementtype} target) {

		try {
			preSetter( $FIELD, target );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

   			get${PropertyName}().remove( target );
    		target.set${inverse} ( null );

		} finally {
			postSetter( $FIELD, target );
		}

	}

	/**
	 * use like remove${Name}
	 */
	public void remove${Name}Set( Set targets ) {

		try {
			preSetter( $FIELD, targets );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

   			get${PropertyName}().removeAll( targets );
    		Iterator it = targets.iterator();
    		while ( it.hasNext() )
    		{
    			${elementtype} target = ($elementtype) it.next();
    			target.set${inverse} ( null );
    		}

		} finally {
			postSetter( $FIELD, targets );
		}

	}

	/**
	 * clears the set.
	 */
	public void clear${PropertyName}() {

		try {
			preSetter( $FIELD, null );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

			get${PropertyName}().clear();
    		Iterator it = iterate${PropertyName}();
    		while ( it.hasNext() )
    		{
    			$elementtype target = ($elementtype) it.next();
    			target.set${inverse} ( null );
    		}

		} finally {
			postSetter( $FIELD, null );
		}

	}

##
## LINK: These methods are like the set methods above, but help to completely
##       hide the link implementations.
##
#elseif( $c2j.hasMetaAttribute($property, "link-add-method") )
#set( $elementtype = $c2j.getMetaAsString($property, "link-add-method"))
#set( $Name = $c2j.unqualify( $elementtype ) )
#set( $LinkType = $c2j.getJavaTypeName($property,true).replaceFirst(".*<","").replaceFirst(">.*",""))
#set( $Link = $c2j.unqualify( $LinkType ) )
#set( $order = $c2j.getMetaAsString($property, "link-add-order"))
#set( $next = $c2j.getMetaAsString($property, "link-add-next"))
#set( $other = $c2j.getMetaAsString($property, "link-add-other"))
#set( $bidir = $c2j.getMetaAsBool($property, "link-add-bidir"))

	/**
	 * adds a $elementtype to ${property.name} . This entails changing our ${property.name} Set,
	 * creating a new $LinkType and calling link${pojo.declarationName} on the $elementtype
	 */
	public void link${Name} ($elementtype addition) {

		try {
			preSetter( $FIELD, addition );

    		// Setup link
    		$LinkType link = new $LinkType();
    		link.link( $order );

    		// Add it to us and possibly the other side.
    		add${Link}( link, true );

		} finally {
			postSetter( $FIELD, addition );
		}

	}

	/**
	 * adds a $LinkType to ${property.name}, allowing for recursion -- whether
	 * or not add${Name} will be called on the addition <b>if it is loaded</b>
	 */
	public void add${Link} ($LinkType link, boolean bothSides) {

		try {
			preSetter( $FIELD, link );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

    		get${PropertyName}().add( link );

#if($bidir)
    		if ( bothSides && link.${other}().isLoaded() )
    			link.${other}().add${Link}( link, false );
#end

		} finally {
			postSetter( $FIELD, link );
		}

	}

	/**
	 * provides an iterator over the $next values of the ${property.name}. Like
	 * with most Collection iterators, modificiations to the underlying collection
	 * while iterating will result in an {@link ConcurrentModificationException}.
	 * Use {@link #linked${Name}List()} instead.
	 */
	 public Iterator linked${Name}Iterator() {

		try {
			preGetter( $FIELD );

    		if ( get${PropertyName}() == null )
    			return new ome.util.EmptyIterator();

            final Iterator it = get${PropertyName}().iterator();
            return new Iterator() {

                public boolean hasNext()
                {
                    return it == null ? false : it.hasNext();
                }

                public Object next()
                {
                    if ( it == null ) throw new NoSuchElementException(
    					"$property.name is null; no elements." );

                    $LinkType link = ($LinkType) it.next();
                    return link.${other}();
                }

                public void remove()
                {
                    throw new UnsupportedOperationException("Cannot call remove on this iterator.");
                }

            };

		} finally {
			postGetter( $FIELD );
		}

    }

	/**
	 * find all ${LinkType} which have the argument as their $other.
	 */
	public Set find${Link}( $elementtype target ) {

		try {
			preGetter( $FIELD );

            final Iterator it = iterate${PropertyName}();
            final Set result = new HashSet();
            while ( it.hasNext() )
            {
                $LinkType link = ($LinkType) it.next();
                if ( link.${other}() == target ) {
                    result.add( link );
                }
            }
            return result;

		} finally {
			postGetter( $FIELD );
		}

    }

	/** produces a {@link List}-copy of the underlying collection. Unlike,
	 *  {@link #linked${Name}Iterator()}, while using the returned {@link List},
	 * modifications can be made to the underlying collection without throwing
	 * {@link ConcurrentModificationExceptions}
	 */
	public List linked${Name}List() {

		try {
			preGetter( $FIELD );

    		Iterator it = linked${Name}Iterator();
    		List list = new ArrayList();

    		while ( it.hasNext() )
    			list.add( it.next() );

    		return list;

		} finally {
			postGetter( $FIELD );
		}

	}

	/**
	 * takes a CBlock and calls the block once for each $elementtype while
	 * collecting the results. If <code>block == null</code>, then the
	 * iterator values themselves are collected.
	 */
	public List eachLinked${Name}(ome.util.CBlock block) {

		try {
			preGetter( $FIELD );

    		List result = new ArrayList();
    		Iterator it = linked${Name}Iterator();
    		while ( it.hasNext() )
    		{
    			IObject obj = (IObject) it.next();
    			if ( block != null )
    			{
    				result.add( block.call( obj ) );
    			} else {
    				result.add( obj );
    			}

    		}
    		return result;

		} finally {
			postGetter( $FIELD );
		}

	}

	/**
	 * unlinks all $elementtype instances from this instance.
	 */
	public void unlink${Name} ($elementtype removal) {

		try {
			preSetter( $FIELD, removal );

    		Set toRemove = find${Link}( removal );
    		Iterator it = toRemove.iterator();
    		while ( it.hasNext() )
    		{
    			remove${Link}( ($LinkType) it.next(), true );
    		}

		} finally {
			postSetter( $FIELD, removal);
		}

	}

	/**
	 * removes the given $Link from ${property.name}, allowing for recursion -- whether
	 * or not the removal will call unlink${pojo.declarationName} again <b>if loaded</b>.
	 */
	public void remove${Link} ($LinkType link, boolean bothSides) {

		try {
			preSetter( $FIELD, link );

			if ( get${PropertyName}() == null )
				throwNullCollectionException("${PropertyName}");

   			get${PropertyName}().remove( link );

#if($bidir)
    		if ( bothSides && link.${other}().isLoaded() )
    			link.${other}().remove${Link}( link, false );
#end

		} finally {
			postSetter( $FIELD, link);
		}

	}

	/**
	 * clears the set.
	 */
	public void clear${Name}Links() {

		try {
			preSetter( $FIELD, null );

			List list = new ArrayList( get${PropertyName}() );
    		for (Object object : list)
            {
    			$LinkType link =
                    ($LinkType) object;
    			remove${Link}( link, true );
    		}

		} finally {
			postSetter( $FIELD, null );
		}

	}

##
##
## ORIGINAL ACCESSORS (with modifications)
##
##
#elseif($pojo.getMetaAttribAsBool($property, "gen-property", true))
#if($pojo.hasFieldJavaDoc($property))
    /**
     * $pojo.getFieldJavaDoc($property, 4)
     */
#end
$templates.Ejb3PropertyGetAnnotation
    $pojo.getPropertyGetModifiers($property) $pojo.getJavaTypeName($property, $jdk5) $pojo.getGetterSignature($property)() {
#if($clazz.identifierProperty.equals($property)||$clazz.version.equals($property))
		return this.$property.name;
#else
		try {
			preGetter( $FIELD );
			return this.$property.name;
		} finally {
			postGetter( $FIELD );
		}

#end
    }

    $pojo.getPropertySetModifiers($property) void set$pojo.getPropertyName($property)($pojo.getJavaTypeName($property, $jdk5) $property.Name) {
#if($clazz.identifierProperty.equals($property)||$clazz.version.equals($property))
        this.$property.Name = $property.Name;
#else
		try {
			preSetter( $FIELD, ${property.name} );
	        this.$property.Name = $property.Name;
		} finally {
			postSetter( $FIELD, ${property.name});
		}
#end
    }

#end
#end
################################################################################
## CLASS LEVEL EXTRA METHODS
################################################################################
##
## Link Type
##
#if( $c2j.hasMetaAttribute($clazz, "link-parent") )
#set( $parent = $c2j.getMetaAsString($clazz, "link-parent"))
#set( $child = $c2j.getMetaAsString($clazz, "link-child"))

	public void link($parent parent, $child child) {

		try {
			preSetter( $FIELD, null );

    		setParent( parent );
    		setChild( child );
		} finally {
			postSetter( $FIELD, null );
		}

	}

	public $parent parent() {

		try {
			preGetter( $FIELD );
			return ($parent) getParent();
		} finally {
			postGetter( $FIELD );
		}

	}

	public $child child() {

		try {
			preGetter( $FIELD );
			return ($child) getChild();
		} finally {
			postGetter( $FIELD );
		}

	}
#end
